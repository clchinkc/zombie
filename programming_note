
OOP Principles in textbook format

Object-oriented programming (OOP) is a programming paradigm that uses objects and their interactions to design applications and computer programs. It is based on several principles:

Encapsulation: This principle states that an object should hide its internal state and behavior from the outside world, and only provide a public interface for other objects to interact with it. This allows the object to control access to its data and behavior, and protects it from unintended changes.

Inheritance: This principle allows an object to inherit the properties and behavior of another object. It enables code reuse and the creation of a hierarchy of objects that share common characteristics.

Polymorphism: This principle allows objects of different types to be treated as objects of a common supertype. It allows objects to be treated in a generic way, without the need to know their specific type.

Abstraction: This principle allows the creation of objects and classes that represent abstract concepts, such as a "vehicle" or "employee". These abstract classes and objects provide a general structure for more specific objects to inherit from, and can be used to create a flexible and easily extensible system.

Class and object: Class is a template or blueprint from which objects are created. Object is an instance of a class.

Association, aggregation, and composition: These principles define the relationships between objects, such as one object being a part of another object (composition: is-a) or one object being associated with another object without being a part of it (association: connect with), or one object contains one or more objects as part of its internal state (aggregation: has-a).

These principles work together to make it possible to design and build robust, flexible, and maintainable software systems using OOP.

FP Principles in textbook format
I. Introduction
Functional programming (FP) is a programming paradigm that emphasizes the use of functions as the primary building blocks of software. This approach emphasizes immutability, recursion, and composition over mutation, iteration, and inheritance. FP has been gaining popularity in recent years, particularly in the realm of web development and data science.

II. Immutability
In functional programming, data is treated as immutable, meaning that it cannot be changed after it is created. This concept is central to functional programming, as it allows for predictable and consistent behavior in software. In contrast, traditional object-oriented programming often relies on mutable data, which can lead to unexpected side effects and bugs.

III. Recursion
Recursion is a technique for solving problems by breaking them down into smaller subproblems. In functional programming, recursion is often used as a way to simplify code and make it more elegant. This is because recursion allows for the abstraction of repetitive tasks, making code more readable and maintainable.

IV. Composition
Functional programming emphasizes the use of composition over inheritance. Composition allows for the creation of new functions by combining existing functions, rather than inheriting functionality from a parent class. This approach promotes code reuse and makes it easier to reason about the behavior of code.

V. Conclusion
Functional programming is a powerful and elegant approach to software development that emphasizes immutability, recursion, and composition. By embracing these principles, developers can create software that is more predictable, maintainable, and reusable. As the popularity of functional programming continues to grow, it is likely that more and more developers will adopt this approach to software development.

Use of object oriented design
1. abstraction: simplify the reality and focus on the relevant data and behaviour of the object
2. encapsulation: the implementation detail are bound together and hidden, only expose the interface of the object to the user, restrict the access and change other data
3. inheritance: the child class can inherit or override the data and behaviour of the parent class, and add its own data and behaviour
4. polymorphism: use the same interface to work with different object but bahave differently according to the object type

SOILD principle of object oriented design:
1. single responsibility principle: a class should have only one reason to change
2. open closed principle: a class should be open for extension, but closed for modification
3. liskov substitution principle: subclass should be substitutable for their base class
4. interface segregation principle: many client-specific interfaces are better than one general-purpose interface
5. dependency inversion principle: depend on abstraction, not on concretion

Guide of object oriented programming:
1. You can combine functional programming and object oriented programming
2. Make classes either data-oriented or behaviour-oriented, not both
3. Use composition over inheritance (one more level of abstraction and hard to understand the interaction)
4. Use dependency injection to decouple the class, and use interface to define the behaviour of the class
5. Use protocol for the dependency inversion principle, which means the class should depend on the interface, not the implementation detail
6. Don't abuse magic methods

Guide of functional programming:
1. Group all side effect (like print, reading and writing file, interacting with database, change a global variable, change a parameter) into one place, usually return instead of printing in the lower level function
2. Use pure function to transform data (pure function is a function that always return the same result if the same parameter is passed in, no random number, does not cause any side effect, and does not depend on any state or data that is not passed in as a parameter and outside dependency, and does not modify any data or objects passed to it as parameters, instead return the new data)
3. Functions are first class object, can be passed as parameter, can be returned by function, can be stored in data structure
4. Make use of immutability and keep the original data unchanged, and return the new data

Functional programming vs object oriented programming:
What are the main basic components of any computer program? They are data (what the program is allowed to know) and programmed behavior (what it is allowed to do with this data). 
What is the key difference in the way OOP and FP are approaching computer programming? Well, the way OOP is using relies on combining data and behaviors related to that data into one place, which is called “object.” Using objects allows programmers to simplify the way their programs work. Functional programming on the other hand states that data and behavior should remain two different things and not be separated for the overall clarity, easily understandable code, and higher code reusability.
1. Concept and definition: OOP is based on the concept of objects as an abstract data type, which can include multiple data and behaviour and may even contain other objects. FP, on the other hand, has a core emphasis on the evaluation of functions, with each function receive and return data and performing a specific behavour on the data.
2. Fundamental elements: In OOP, the fundamental elements are objects and methods, with mutable data used. In FP, the fundamental elements are functions and variables, with data in functions being immutable.
1. functional programming is more declarative, object oriented programming is more imperative (functional programming is more about describing the desired outcome, object oriented programming is more about how to accomplish a task)
2. functional programming is more about using pure function to transform data, object oriented programming is more about using object and its state to perform behaviour. Use functional programming if the state needs to be stored, use object oriented programming if the behaviour is complex
4. Modularity and abstraction: OOP achieves modularity and abstraction through encapsulation and inheritance, where the internal details of an object are hidden and only a public interface is exposed.  FP achieves modularity and abstraction through the composition and reuse of single-purpose functions, higher-order functions, and closures, which allow for composable, reusable, and generic functions.
4. Concurrency and parallelism: OOP can face difficulties in concurrent and parallel programming due to its reliance on shared mutable state. FP, on the other hand, is better suited for concurrent and parallel programming due to its emphasis on immutability and the avoidance of side-effects.
7. Functional programming is more suited for functional testing as it allows you to test each function independently, whereas OOP requires testing the entire object and its interactions with other objects.
8. Functional programming is more suitable for mathematical and computational problems, whereas OOP is more suitable for modelling real-world objects and their interactions.
9. Flexibility and adding data/functions: OOP languages provide an easy way to add new data and functions to the existing program, whereas in FP languages, adding new things to programs is less convenient and more complex.
10. Data hiding and security: OOP languages support data hiding, which ultimately allows the creation of secure programs. With functional programming, data hiding is not possible, which can be an obstacle if you are looking to develop a secure program with an FP language.

OOP and FP are two different programming paradigms, each with its own pros and cons. OOP is more commonly used and is better suited for large and complex projects. It is relatively easy to understand and master, making it suitable for beginners. OOP works well in back-end development as it allows for packing everything up and keeping it secure from unauthorized parties. However, OOP can have lower code reusability and potential unexpected side effects.
Functional programming is better suited for when complexity is contained and specified, and is often used in front-end development where clean code and transparent functions are important. It can provide a reliable performance without unexpected side effects. However, when it comes to the development of complex systems that would potentially need extensive scaling, FP is less effective and applicable compared to OOP.

Procedural programming vs Functional programming vs Object-oriented programming

Functional programming focuses on expressions
Expressions have values which undergo computational instruction as evaluation of mathematical functions but there's no way to manipulate the state.

Procedural programming focuses on statements
Statements don't have values and instead modify the inner state.

Objective programming, also known as object-oriented programming, is a programming paradigm that focuses on the use of objects and their interactions to design and implement software. It is based on the concepts of classes, objects, encapsulation, inheritance, and polymorphism.

Procedural programming would plan everything into steps, and solves the problem by implementing one step (a procedure) at a time. On the other hand, functional programming would emphasize the divide-and-conquer approach, where the problem is divided into sub-problem, then each sub-problem is solved (creating a function to solve that sub problem) and the results are combined to create the answer for the whole problem. Lastly, Objective programming would mimic the real world by create a mini-world inside the computer with many objects, each of which has a (somewhat) unique characteristics, and interacts with others. From those interactions the result would emerge.


guide to write function:
1. do one thing and do it well
2. separate command (perform action) from query (retrieve information) (command should not return anything, query should not change the state of the program)
3. only require information that is needed (get one level of abstraction lower)
4. keep number of parameter minimal
5. don't create and use an object in the same place (therefore the factory pattern)
6. don't use flag parameter (a parameter that can change the behaviour of a function completely, usually a boolean),  use multiple function instead
7. avoid side effect (a function that change the state of the program, like print, change a global variable, change a parameter)
8. remember function is first class object, can be passed as parameter, can be returned by function, can be stored in data structure


guide to write class:
1. encapsulate what varies (encapsulate the behaviour that is different, not the data)
2. favour composition over inheritance (use composition to build a class, use inheritance to build a hierarchy)
3. program to interface, not implementation (use interface to define the behaviour of the class, not the implementation detail)
4. use delegation to reuse code (use delegation to reuse the behaviour of the class, not the data)
5. separate the implemntation detail from the interface (use interface to define the behaviour of the class, not the implementation detail)

Composition over inheritance
When to Use Component over Extension:
When a single entity spans multiple domains and it's important to keep them isolated, use a component class for each domain. This will reduce the entity to a simple container of components. This will allow for more flexibility in managing and modifying the different domains and even adding functionality without affecting the rest of the entity or creating a hierarchy.
When you have a class that interacts with multiple domains and you want to keep the functionality decoupled, use composition to create separate component classes for each domain to keep the functionality separate and maintain a clear separation of concerns.
When you want to define a variety of objects that share different capabilities, but using inheritance does not provide enough granularity in reusing specific capabilities, use composition to selectively add the desired capabilities to each object.
When to Use Extension Over Component:
When you have a class that has a single clear responsibility and you want to add a specific functionality to it, use inheritance (extension) to inherit from the base class and add the desired functionality.
When you have a clear hierarchy of classes and want to maintain the inheritance structure, use extension to inherit from the parent class and add new functionality.
When you want to reuse a common functionality across multiple classes, use extension to create a base class with the common functionality and inherit from it in other classes.
When the added functionality is closely related to the existing functionality of the class, use extension to keep the functionality together in the same class.

design pattern:
1. factory pattern: creational design pattern, separate the creation and use of the object, lets you define an interface for creating objects, but decide the creation logic using different subclasses at run-time.
The Factory Method pattern is a creational design pattern that provides an interface for creating objects in a superclass but allows subclasses to alter the type of objects that will be created. The Factory Method pattern is often used to create objects that belong to a particular family or class, but don't necessarily have the same type.
The Abstract Factory pattern is a creational design pattern that provides an interface to group related to or dependent to object factories. The Abstract Factory pattern is often used to create objects that belong to a particular family or group and have a certain relationship or dependency between them.
The factory may have different methods to receive different parameters during runtime (abstract factory pattern), return object from the object pool (object pool pattern), do different configuration (strategy pattern), and to create different objects (factory method pattern)
https://www.youtube.com/watch?v=zGbPd4ZP39Y
2. strategy pattern
The Strategy Pattern is a behavioural design pattern that allows for the selection from a family of algorithms. It defines a family of algorithms, encapsulates each algorithm into a separate class, and makes them interchangeable within the family.
This is achieved by creating an abstract class and providing a common interface that utilizes various concrete data classes, without the need to know the implementation details.
The pattern should be used when the desired behaviour needs to be selected at runtime based on input or other factors. By separating the logic of an algorithm from its usage, the same algorithm can be used in multiple classes, and new algorithms can be added to the program without modifying existing code.
3. template method pattern
Template Method is a behavioral design pattern that defines the skeleton of an algorithm in the template method of the superclass, deferring the details to subclasses. Template method lets subclasses customize certain steps of the algorithm without changing the algorithm's overall structure.
The abstract class defines a template method that define the overall structure of the algorithm, including calls to abstract methods that are implemented by subclasses. The template method can also include concrete methods that provide a default implementation for some of the steps of the algorithm. This provides a way to define a common behavior for a set of related classes, while allowing for variations in the details of the behavior.
This pattern is often used in situations where a common set of steps needs to be performed, but the implementation of one or more of those steps may vary.

Not suitable to implement:
3. builder pattern
The Builder pattern is a design pattern that separates the construction of a complex object from its representation. The idea behind this pattern is to break down the construction of a complex object into smaller, manageable steps that can be executed in a specific order, often building a composite object. This allows for greater flexibility and control over the final product, as well as the ability to change the type or representation of the object at any step.
The pattern is typically implemented using classes and methods to create and configure an object, with the final "build" step returning the fully constructed object. The builder object encapsulates the configuration (state) of the complex object, and the Director object is responsible for coordinating the construction process and using the Builder object (its inner class to avoid telescoping constructors) to create the final product. By exchanging the Builder in the Director, the same algorithm can be used to create the product, but with different representations of single parts.
The Builder pattern is particularly useful when creating standard objects with lots of possible customizations, but usually customizing just a few, or when the dependencies of the object to be instantiated are partly known in advance and partly provided by the client of the builder.
In addition, the Builder pattern focuses on constructing a complex object step by step and decouples the representation from the construction process. This means that the same construction process can be used for different representations.
A builder pattern allows you to use setter methods to slowly build up your parameter list and passes the builder object into the desired constructor to return the result.
4. bridge pattern
decouple an abstraction from its implementation so that the two can vary independently
Chapter 1: Introduction to the Bridge Design Pattern
1.1 Overview
The Bridge pattern is a structural design pattern used to decouple an abstraction from its implementation. This pattern involves creating an interface or abstract class that defines the methods that the implementation must provide, and then creating a separate implementation class that implements those methods. This allows for a standardized interface while still allowing for different implementations for the same interface.
1.2 Abstraction and Decoupling
One key aspect of the Bridge pattern is that it creates a refined abstraction between the abstraction (interface) and implementation (class). This abstraction is not tied to the implementation and serves to completely decouple the two. This allows the abstraction and implementation to be changed independently even in run time, without affecting the client code that uses it.
The Bridge pattern is particularly useful when you want run-time binding of the implementation, when you have a proliferation of classes resulting from a coupled interface and numerous implementations, when you want to share an implementation among multiple objects, or when you need to map orthogonal class hierarchies. When the context, or the class that the implementation is being decoupled from, has subclasses, this pattern allows for the implementation to be customized for each of these variations. This fits the principle to use composition over inheritance.
1.3 Structural Hierarchy and Flexibility
The Bridge pattern is a design pattern that aims to deals with the structural hierarchy and separate the two orthogonal concept of the bigger object, by using composition rather than inheritance to link them. This reduce the number of classes needed and linking the two orthogonal class hierarchies.
The key feature of this pattern is that the implementation never refers to the abstraction, and the abstraction contains the implementation interface as a member through composition. This composition reduces one more level of inheritance hierarchy.
1.4 Relationship to Other Patterns
It's worth noting that the Bridge pattern is related to other design patterns such as the Strategy, Template Method, and Composite patterns. The Bridge pattern is similar to the Strategy pattern in that it allows for changing the behaviour of a software component depending on a given implementer. However, the Bridge pattern also adds an additional layer of abstraction, making the design even more flexible. Bridge and Strategy patterns are structural patterns that are used to separate an abstraction from its implementation. The Bridge pattern links one abstraction to another, where the client depends on an abstract API that is implemented in terms of a separate, differing API. The implementor is hidden from the client and does not match the client API. The client API forwards all calls to the implementor. On the other hand, the Strategy pattern links an implementation to an abstraction. The client chooses a concrete strategy, and its API is known and matches the client's requirement, as one piece of a client implementation. The client implementation forwards one specific operation to the strategy. In summary, Bridge is useful when the client depends on an abstract API that is implemented in terms of a separate, differing API, while the Strategy pattern is useful when the client is a concrete implementation whose behavior can be modified by using multiple algorithms. Additionally, the Bridge pattern is similar to the Template Method pattern in that it calls methods in the same order as the template method, but allows for the behaviour to be changed depending on the implementer as in the Strategy pattern. The Bridge pattern is a structural pattern, which means it focuses on how the composition of the components. It is different from the Strategy pattern, which is a dynamic pattern that focuses on how to run behaviour in software. This pattern is often used in conjunction with the Composite pattern to create a tree structure of objects, where each node in the tree can be an abstraction or implementation. Adapter is used when you're trying to unify the interfaces of some incompatible classes that already exist. The Adapter functions as a kind of translator to implementations that could be considered legacy. At first sight, the Bridge pattern looks a lot like the Adapter pattern in that a class is used to convert one kind of interface to another. However, the intent of the Adapter pattern is to make one or more classes' interfaces look the same as that of a particular class. The Bridge pattern is designed to separate a class's interface from its implementation so you can vary or replace the implementation without changing the client code.
1.5 Example
There are four components in this pattern.
Abstraction: It defines an interface
RefinedAbstraction: It implements abstraction:
Implementor: It defines an interface for implementation
ConcreteImplementor: It implements Implementor interface.
For example, we can have a 'Car' interface and two classes that implement this interface: 'SportsCar' and 'Truck'. The 'Car' interface will have the methods and properties that both 'SportsCar' and 'Truck' classes should have. Then, we define the 'SportsCar' and 'Truck' classes that will have their own unique implementations of the 'drive' method. The 'SportsCar' class can have a drive method that prints "Driving a sports car at high speed!" and the 'Truck' class can have a drive method that prints "Driving a truck at low speed." Now we can create instances of these classes and use them interchangeably without changing the implementation of the car class. This allows us to add new subclasses with new implementations without modifying the Car class and this make the code more maintainable and flexible.


3. mixin pattern
https://andrewbrookins.com/technology/mixins-in-python-and-ruby-compared/
4. plugin pattern: let the user to add new behaviour to the object without modifying the existing code at runtime, by adding new plugin
https://github.com/ArjanCodes/2021-plugin-architecture

7. composite pattern: compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly
9. iterator pattern: provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation
10. observer pattern: define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically
https://www.youtube.com/watch?v=oNalXg67XEE
11. command pattern: encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations
12. proxy pattern: provide a surrogate or placeholder for another object to control access to it
13. flyweight pattern: use sharing to support large numbers of fine-grained objects efficiently
14. facade pattern: provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use
16. memento pattern: without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state later
17. visitor pattern: represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates
18. chain of responsibility pattern: avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it
19. interpreter pattern: given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language
20. mediator pattern: define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently
21. prototype pattern: specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype
22. abstract factory pattern: provide an interface for creating families of related or dependent objects without specifying their concrete classes

Not suggested design pattern:
22. singleton pattern
ensure only one instance of the class exist and provide a global point of access to create the instance if it doesn't exist
23. delegate pattern
Delegation Pattern is a structural design pattern that lets you pass necessary requests from a client object (main object) to a service object (helper object) without making the service object a part of the client object's class, by using meta-programming.
https://erikscode.space/index.php/2020/08/01/delegate-and-decorate-in-python-part-1-the-delegation-pattern/
24. decorator pattern
Decorator Pattern is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors, provide a flexible alternative to subclassing for extending functionality
https://erikscode.space/index.php/2020/08/02/delegate-and-decorate-in-python-part-2-the-decorator-pattern/
Reusable decorator
Decorator with other attributes and methods can inherit from base decorator class
https://erikscode.space/index.php/2020/08/03/delegate-and-decorate-in-python-part-3-reusable-decorators/
25. lazy initialization pattern
Lazy initialization is a design pattern that delays the creation of an object, the calculation of a value, or some other expensive process until the first time it is needed
5. adapter pattern: convert the interface of a class into another interface the clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces
Adapter is recognizable by a constructor which takes an instance of a different abstract/interface type. When the adapter receives a call to any of its methods, it translates parameters to the appropriate format and then directs the call to one or several methods of the wrapped object.
The Adapter pattern is pretty common in Python code. It’s very often used in systems based on some legacy code. In such cases, Adapters make legacy code work with modern classes.
https://refactoring.guru/design-patterns/adapter/python/example
8. state pattern: allow an object to alter its behaviour when its internal state changes. The object will appear to change its class


optimization:
1. refactor and extract method
2. use cache
3. early exit
1. don't repeat yourself (DRY)
2. list comprehension
3. no multiple inheritance
4. change to immutable object when possible
5. use generator when possible
6. change to float
7. use built-in function

Implementation:
1. classmethod: depend on the class, not the instance, so can be called using class or instance
2. staticmethod: don't depend on the class or instance, so can be called anywhere without depending on the class or instance, so function related to class but does not interact with class and instance can be grouped under the class
3. dataclass: struct-like data container, can be used to store data, but not behaviour
4. property: getter, setter, deleter
5. decorator: used to add functionality to an existing function without modifying it, can be used to add logging, timing, authentication, etc
6. __slots__: reduce memory usage, but can't add new attribute
7. currying function: can be used when a sequence of separate function is used on the same object
9. nested function: used when the function should be hide from the outside or the inner function is only used in the outer function
10. __call__: used to make an instance callable as a function, a() == call
11. __init__: used to initialize the object and return nothing, a = A() == init
12. __new__: used to create the object and return the object
13. iterable: data structure that can be looped over, can be used in for loop, e.g. list, tuple, string, dict, set, range, etc
14. iterator: have __iter__ and __next__ method, can be used to return a sequence of data
13. Closure:
A closure is a function defined inside another function, which has access to the intermediate variables of the outer function. The main advantage of using closures is that it allows a function to maintain some sort of internal state, or have access to variables in the functional scope, even outside the original scope, without having to pass them around as arguments. This allows for avoiding the use of global variables while still having access to the variables of the outer function.
You should use closures when you need a function to maintain some sort of internal state, or when you need a function to have access to certain variables in the function scope . Some examples include:
Counting the number of times a function is called
Creating a function that generates unique IDs
Creating a function that has access to a specific configuration or settings, like a database connection or a logging configuration
Creating a function that maintains the state of a program, such as a game or a user session
It is not recommended to use closures in situations where the state that needs to be maintained is global or shared among different functions, it is better to use a global variable or a class-based solution. Additionally, if the closure function is going to be used by many different parts of the program, it can become difficult to keep track of its state and can lead to unexpected behavior.

Chapter 1: Introduction to Object-Oriented Programming
Chapter 2: Classes and Objects
Chapter 3: Inheritance and Polymorphism
Chapter 4: Object-Oriented Design Principles
Chapter 5: Encapsulation and Information Hiding
Chapter 6: Abstraction and Interfaces
Chapter 7: Composition over Inheritance

In object-oriented programming, polymorphism allows for a single action to be performed in different ways by defining one interface and multiple implementations. One way to achieve polymorphic behavior and code reuse is through the principle of composition over inheritance.

Composition is a way to combine objects or data types into more complex ones, rather than inheriting from a base or parent class. This is achieved through a "has-a" relationship, where a class is designed based on what it does, rather than what it is. In contrast, inheritance uses an "is-a" relationship, where a child class inherits behaviors from a parent class.

The main advantage of composition is that it is more flexible than inheritance. Classes and objects created through composition are loosely coupled, making it easier to change the component parts. This allows for greater flexibility in program design and ease of maintenance.

It's important to note that composition and inheritance are not mutually exclusive concepts. In situations where a super class and subclass share the exact same implementation, inheritance may be the more appropriate choice. However, when many classes share a behavior that is common across different hierarchies, composition through the use of interfaces or design patterns may be more suitable.

When implementing composition, there is no single "correct" way as it depends on the language. Techniques such as interfaces, object merging, and design patterns can be used to achieve composition. However, one drawback of composition is that methods provided by the component may have to be re-implemented.

In summary, composition over inheritance is a principle used in object-oriented programming to achieve polymorphic behavior and code reuse by composing objects out of other objects, rather than trying to find commonality between them and creating an inheritance hierarchy. Composition is a more flexible approach that allows for greater flexibility in program design and ease of maintenance. However, it is important to consider the specific needs of a program before deciding whether to use composition or inheritance.

Chapter 8: SOLID Principles
Chapter 9: Design Patterns and their Implementation
Chapter 10: Dependency Injection and Dependency Inversion
Chapter 11: Concurrency, Multithreading, and Optimization
Chapter 12: Exception Handling, Debugging, and Troubleshooting
Chapter 13: Testing and Validation
Chapter 14: Deployment and Maintenance
Chapter 15: Object-Oriented Design in Practice
