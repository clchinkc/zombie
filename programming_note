
Use of object oriented design
1. abstraction: simplify the reality and focus on the relevant feature, like the data and behaviour, of the object
2. encapsulation: the implementation detail are bound together and hidden, only expose the interface of the object to the user
3. inheritance: the child class can inherit or override the data and behaviour of the parent class, and add its own data and behaviour
4. polymorphism: different object can have the same interface, and the user can use the same interface to interact with different object

SOILD principle of object oriented design:
1. single responsibility principle: a class should have only one reason to change
2. open closed principle: a class should be open for extension, but closed for modification
3. liskov substitution principle: subclass should be substitutable for their base class
4. interface segregation principle: many client-specific interfaces are better than one general-purpose interface
5. dependency inversion principle: depend on abstraction, not on concretion

Guide of object oriented programming:
1. You can combine functional programming and object oriented programming
2. Make classes either data-oriented or behaviour-oriented, not both
3. Use composition over inheritance (one more level of abstraction and hard to understand the interaction)
4. Use dependency injection to decouple the class, and use interface to define the behaviour of the class
5. Use protocol for the dependency inversion principle, which means the class should depend on the interface, not the implementation detail
6. Don't abuse magic methods

Guide of functional programming:
1. Group all side effect (like print, reading and writing file, interacting with database, change a global variable, change a parameter) into one place, usually return instead of printing in the lower level function
2. Use pure function to transform data (pure function is a function that always return the same result if the same parameter is passed in, no random number, does not cause any side effect, and does not depend on any state or data that is not passed in as a parameter and outside dependency, and does not modify any data or objects passed to it as parameters, instead return the new data)
3. Functions are first class object, can be passed as parameter, can be returned by function, can be stored in data structure
4. Make use of immutability and keep the original data unchanged, and return the new data

Functional programming vs object oriented programming:
1. functional programming is more declarative, object oriented programming is more imperative (functional programming is more about what to do, object oriented programming is more about how to do it)
2. functional programming is more about using pure function to transform data, object oriented programming is more about using object and its state to perform behaviour
3. use functional programming if the state needs to be stored, use object oriented programming if the behaviour is complex

guide to write function:
1. do one thing and do it well
2. separate command (perform action) from query (retrieve information) (command should not return anything, query should not change the state of the program)
3. only require information that is needed (get one level of abstraction lower)
4. keep number of parameter minimal
5. don't create and use an object in the same place (therefore the factory pattern)
6. don't use flag parameter (a parameter that can change the behaviour of a function completely, usually a boolean),  use multiple function instead
7. avoid side effect (a function that change the state of the program, like print, change a global variable, change a parameter)
8. remember function is first class object, can be passed as parameter, can be returned by function, can be stored in data structure


guide to write class:
1. encapsulate what varies (encapsulate the behaviour that is different, not the data)
2. favour composition over inheritance (use composition to build a class, use inheritance to build a hierarchy)
3. program to interface, not implementation (use interface to define the behaviour of the class, not the implementation detail)
4. use delegation to reuse code (use delegation to reuse the behaviour of the class, not the data)
5. separate the implemntation detail from the interface (use interface to define the behaviour of the class, not the implementation detail)

design pattern:
1. factory pattern: creational design pattern, separate the creation and use of the object, lets you define an interface for creating objects, but decide the creation logic using different subclasses at run-time.
https://www.youtube.com/watch?v=zGbPd4ZP39Y
2. strategy pattern
The Strategy Pattern is a behavioural design pattern that allows for the selection from a family of algorithms. It defines a family of algorithms, encapsulates each algorithm into a separate class, and makes them interchangeable within the family.
This is achieved by creating an abstract class and providing a common interface that utilizes various concrete data classes, without the need to know the implementation details.
The pattern should be used when the desired behaviour needs to be selected at runtime based on input or other factors. By separating the logic of an algorithm from its usage, the same algorithm can be used in multiple classes, and new algorithms can be added to the program without modifying existing code.

3. plugin pattern: let the user to add new behaviour to the object without modifying the existing code at runtime, by adding new plugin
https://github.com/ArjanCodes/2021-plugin-architecture
4. singleton pattern: ensure a class only have one instance, and provide a global point of access to it
5. observer pattern: define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically
https://www.youtube.com/watch?v=oNalXg67XEE
6. command pattern: encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations
7. adapter pattern: convert the interface of a class into another interface the clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces
8. template method pattern: define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure
9. iterator pattern: provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation
10. composite pattern: compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly
11. state pattern: allow an object to alter its behaviour when its internal state changes. The object will appear to change its class
12. proxy pattern: provide a surrogate or placeholder for another object to control access to it
13. flyweight pattern: use sharing to support large numbers of fine-grained objects efficiently
14. facade pattern: provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use
15. bridge pattern: decouple an abstraction from its implementation so that the two can vary independently
16. memento pattern: without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state later
17. visitor pattern: represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates
18. chain of responsibility pattern: avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it
19. interpreter pattern: given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language
20. mediator pattern: define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently
21. prototype pattern: specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype
22. abstract factory pattern: provide an interface for creating families of related or dependent objects without specifying their concrete classes

Not suggested design pattern:
23. delegate pattern
Delegation Pattern is a structural design pattern that lets you pass necessary requests from a client object (main object) to a service object (helper object) without making the service object a part of the client object's class, by using meta-programming.
https://erikscode.space/index.php/2020/08/01/delegate-and-decorate-in-python-part-1-the-delegation-pattern/

24. decorator pattern
Decorator Pattern is a structural design pattern that lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors, provide a flexible alternative to subclassing for extending functionality
https://erikscode.space/index.php/2020/08/02/delegate-and-decorate-in-python-part-2-the-decorator-pattern/
Reusable decorator
Decorator with other attributes and methods can inherit from base decorator class

class Decorator:
  def __init__(self, model):
    self.model = model
    self.model_methods = [f for f in dir(type(self.model)) if not f.startswith('_')]
    self.model_attributes = [a for a in self.model.__dict__.keys()]
  
  def __getattr__(self, func):
    if func in self.model_methods:
      def method(*args):
        return getattr(self.model, func)(*args)
      return method
    elif func in self.model_attributes:
      return getattr(self.model, func)
    else:
      raise AttributeError
      
class LeashedDogDecorator(Decorator):
  def __init__(self, dog):
    super().__init__(dog)
  
  def tug_on_leash(self):
    print("Let's GOOOOO!!!")
    
>>> dog = Dog('Fido', 4)
>>> dog = LeashedDogDecorator(dog)
>>> dog.tug_on_leash()
Let's GOOOOO!!!
>>> dog.bark()
Woof woof

https://erikscode.space/index.php/2020/08/03/delegate-and-decorate-in-python-part-3-reusable-decorators/



optimization:
1. refactor and extract method
2. use cache
3. early exit
1. don't repeat yourself (DRY)
2. list comprehension
3. no multiple inheritance
4. change to immutable object when possible
5. use generator when possible
6. change to float
7. use built-in function

Implementation:
1. classmethod: depend on the class, not the instance, so can be called using class or instance
2. staticmethod: don't depend on the class or instance, so can be called anywhere without depending on the class or instance, so function related to class but does not interact with class and instance can be grouped under the class
3. dataclass: struct-like data container, can be used to store data, but not behaviour
4. property: getter, setter, deleter
5. decorator: used to add functionality to an existing function without modifying it, can be used to add logging, timing, authentication, etc
6. __slots__: reduce memory usage, but can't add new attribute
7. currying function: can be used when a sequence of separate function is used on the same object
9. nested function: used when the function should be hide from the outside or the inner function is only used in the outer function
10. __call__: used to make an instance callable as a function, a() == call
11. __init__: used to initialize the object and return nothing, a = A() == init
12. __new__: used to create the object and return the object
13. iterable: data structure that can be looped over, can be used in for loop, e.g. list, tuple, string, dict, set, range, etc
14. iterator: have __iter__ and __next__ method, can be used to return a sequence of data
13. Closure:
A closure is a function defined inside another function, which has access to the intermediate variables of the outer function. The main advantage of using closures is that it allows a function to maintain some sort of internal state, or have access to variables in the functional scope, even outside the original scope, without having to pass them around as arguments. This allows for avoiding the use of global variables while still having access to the variables of the outer function.
You should use closures when you need a function to maintain some sort of internal state, or when you need a function to have access to certain variables in the function scope . Some examples include:
Counting the number of times a function is called
Creating a function that generates unique IDs
Creating a function that has access to a specific configuration or settings, like a database connection or a logging configuration
Creating a function that maintains the state of a program, such as a game or a user session
It is not recommended to use closures in situations where the state that needs to be maintained is global or shared among different functions, it is better to use a global variable or a class-based solution. Additionally, if the closure function is going to be used by many different parts of the program, it can become difficult to keep track of its state and can lead to unexpected behavior.