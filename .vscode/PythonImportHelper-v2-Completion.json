[
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "astuple",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "nltk",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "nltk",
        "description": "nltk",
        "detail": "nltk",
        "documentation": {}
    },
    {
        "label": "string",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "string",
        "description": "string",
        "detail": "string",
        "documentation": {}
    },
    {
        "label": "time,sys,os,threading,copy,random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time.sys.os.threading.copy.random",
        "description": "time.sys.os.threading.copy.random",
        "detail": "time.sys.os.threading.copy.random",
        "documentation": {}
    },
    {
        "label": "getkey",
        "importPath": "getkey",
        "description": "getkey",
        "isExtraImport": true,
        "detail": "getkey",
        "documentation": {}
    },
    {
        "label": "keys",
        "importPath": "getkey",
        "description": "getkey",
        "isExtraImport": true,
        "detail": "getkey",
        "documentation": {}
    },
    {
        "label": "master_maze",
        "importPath": "mazes",
        "description": "mazes",
        "isExtraImport": true,
        "detail": "mazes",
        "documentation": {}
    },
    {
        "label": "db",
        "importPath": "replit",
        "description": "replit",
        "isExtraImport": true,
        "detail": "replit",
        "documentation": {}
    },
    {
        "label": "clear",
        "importPath": "replit",
        "description": "replit",
        "isExtraImport": true,
        "detail": "replit",
        "documentation": {}
    },
    {
        "label": "generate",
        "importPath": "maze_gen",
        "description": "maze_gen",
        "isExtraImport": true,
        "detail": "maze_gen",
        "documentation": {}
    },
    {
        "label": "heapq",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "heapq",
        "description": "heapq",
        "detail": "heapq",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "auto",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "cached_property",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "partial",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "update_wrapper",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "update_wrapper",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "animation",
        "importPath": "matplotlib",
        "description": "matplotlib",
        "isExtraImport": true,
        "detail": "matplotlib",
        "documentation": {}
    },
    {
        "label": "fsolve",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "solve_ivp",
        "importPath": "scipy.integrate",
        "description": "scipy.integrate",
        "isExtraImport": true,
        "detail": "scipy.integrate",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "tensorflow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tensorflow",
        "description": "tensorflow",
        "detail": "tensorflow",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "performance_decorator",
        "importPath": "timeit_decorator",
        "description": "timeit_decorator",
        "isExtraImport": true,
        "detail": "timeit_decorator",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "cProfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cProfile",
        "description": "cProfile",
        "detail": "cProfile",
        "documentation": {}
    },
    {
        "label": "pstats",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pstats",
        "description": "pstats",
        "detail": "pstats",
        "documentation": {}
    },
    {
        "label": "timeit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "timeit",
        "description": "timeit",
        "detail": "timeit",
        "documentation": {}
    },
    {
        "label": "line_profiler",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "line_profiler",
        "description": "line_profiler",
        "detail": "line_profiler",
        "documentation": {}
    },
    {
        "label": "memory_profiler",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "memory_profiler",
        "description": "memory_profiler",
        "detail": "memory_profiler",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "class Agent(ABC):\n    @abstractmethod\n    def __init__(self, id: int, health: int, position: tuple[int, int]):\n        self.id = id\n        self.health = health\n        self.position = position\n        # 0's and 1's to represent the agent's genome\n        # the genome can be used to determine the agent's behavior\n        # state, health and size can be used to determine the agent's fitness\n        # location, direction, speed, energy, infection, infection time, death",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "AgentManager",
        "kind": 6,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "class AgentManager(ABC):\n    @abstractmethod\n    def __init__(self):\n        self.agents = []\n    @abstractmethod\n    def add_agent(self, agent: Agent) -> None:\n        pass\n    @abstractmethod\n    def remove_agent(self, agent: Agent) -> None:\n        pass",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "Human",
        "kind": 6,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "class Human(Agent):\n    def __init__(self, id, health, position, weapon=None):\n        super().__init__(id, health, position)\n        self.weapon = weapon\n        self.connections = []\n    @property\n    def health(self):\n        return self._health\n    @health.setter\n    def health(self, value):",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "HumanManager",
        "kind": 6,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "class HumanManager(AgentManager):\n    def __init__(self):\n        # List of all humans in the apocalypse\n        self.humans = []\n    def add_agent(self, human):\n        self.humans.append(human)\n    def remove_agent(self, human):\n        self.humans.remove(human)\n    def get_agents_in_range(self, agent: Agent, range: float):\n        return super().get_agents_in_range(agent, range)",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "Zombie",
        "kind": 6,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "class Zombie(Agent):\n    def __init__(self, id, health, position):\n        super().__init__(id, health, position)\n        self.connections = []\n    @property\n    def health(self):\n        return self._health\n    @health.setter\n    def health(self, value):\n        self._health = value",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "ZombieManager",
        "kind": 6,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "class ZombieManager(AgentManager):\n    def __init__(self):\n        # List of all zombies in the apocalypse\n        self.zombies = []\n    def add_agent(self, zombie):\n        self.zombies.append(zombie)\n    def remove_agent(self, zombie):\n        self.zombies.remove(zombie)\n    def get_enemies_in_attack_range(self, agent):\n        attack_range = math.sqrt(2+ agent.weapon.range) if (isinstance(agent, Human) and agent.weapon is not None) else math.sqrt(2)",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "Weapon",
        "kind": 6,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "class Weapon:\n    trading_value: int = field(init=False, repr=False) # the value of the weapon in trading function\n    name: str\n    damage: int = 0\n    range: int = 0\n    def __post_init__(self):\n        object.__setattr__(self, \"trading_value\", self.damage * self.range)\n    def __iter__(self):\n        yield from astuple(self)\n    def __str__(self):",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "AbstractAgentFactory",
        "kind": 6,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "class AbstractAgentFactory(ABC):\n    @abstractmethod\n    def create_agent(self, **kwargs) -> Agent:\n        raise NotImplementedError()\nclass HumanFactory(AbstractAgentFactory):\n    def create_agent(self, **kwargs) -> Agent:\n        return Human(**kwargs)\nclass ZombieFactory(AbstractAgentFactory):\n    def create_agent(self, **kwargs) -> Agent:\n        return Zombie(**kwargs)",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "HumanFactory",
        "kind": 6,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "class HumanFactory(AbstractAgentFactory):\n    def create_agent(self, **kwargs) -> Agent:\n        return Human(**kwargs)\nclass ZombieFactory(AbstractAgentFactory):\n    def create_agent(self, **kwargs) -> Agent:\n        return Zombie(**kwargs)\n# Factory method Pattern\nclass AgentFactory:\n    def __init__(self):\n        self.character_creation_funcs: dict[str, Callable[..., AbstractAgentFactory]] = {}",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "ZombieFactory",
        "kind": 6,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "class ZombieFactory(AbstractAgentFactory):\n    def create_agent(self, **kwargs) -> Agent:\n        return Zombie(**kwargs)\n# Factory method Pattern\nclass AgentFactory:\n    def __init__(self):\n        self.character_creation_funcs: dict[str, Callable[..., AbstractAgentFactory]] = {}\n    def register_character(self, character_type: str, creator_fn: Callable[..., AbstractAgentFactory]) -> None:\n        \"\"\"Register a new game character type.\"\"\"\n        self.character_creation_funcs[character_type] = creator_fn",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "AgentFactory",
        "kind": 6,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "class AgentFactory:\n    def __init__(self):\n        self.character_creation_funcs: dict[str, Callable[..., AbstractAgentFactory]] = {}\n    def register_character(self, character_type: str, creator_fn: Callable[..., AbstractAgentFactory]) -> None:\n        \"\"\"Register a new game character type.\"\"\"\n        self.character_creation_funcs[character_type] = creator_fn\n    def unregister_character(self, character_type: str) -> None:\n        \"\"\"Unregister a game character type.\"\"\"\n        self.character_creation_funcs.pop(character_type, None)\n    def produce(self, arguments: dict[str, Any]) -> Agent:",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "Game",
        "kind": 6,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "class Game(ABC):\n        # template method pattern\n        @abstractmethod\n        def __init__(self, grid, agentfactory):\n            self.grid = grid\n            self.agentfactory = agentfactory\n            self.agents = []\n        @abstractmethod\n        def simulate(self, agent_count, num_turns):\n            self.initialize(agent_count)",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "ZombieApocalypse",
        "kind": 6,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "class ZombieApocalypse(Game):\n    def __init__(self):\n        self.human_manager = HumanManager() # the human manager instance to manage the humans\n        self.zombie_manager = ZombieManager() # the zombie manager instance to manage the zombies\n        self.factory = AgentFactory()\n        self.possible_weapons = [\n            Weapon(\"Baseball Bat\", 20, 2),\n            Weapon(\"Pistol\", 30, 5),\n            Weapon(\"Rifle\", 40, 8),\n            Weapon(\"Molotov Cocktail\", 50, 3),",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "apocalypse",
        "kind": 5,
        "importPath": "agent",
        "description": "agent",
        "peekOfCode": "apocalypse = ZombieApocalypse()\napocalypse.simulate(num_zombies=10, \n                    num_humans=10, \n                    school_size=10, \n                    num_turns=10)\n\"\"\"\nChange the inheritance to abstract class or protocol\n\"\"\"\n\"\"\"\ntake damage not working",
        "detail": "agent",
        "documentation": {}
    },
    {
        "label": "InputComponent",
        "kind": 6,
        "importPath": "component",
        "description": "component",
        "peekOfCode": "class InputComponent(ABC):\n    @abstractmethod\n    def update(self, obj):\n        pass\nclass PlayerInputComponent(InputComponent):\n    def __init__(self) -> None:\n        self.WALK_ACCELERATION = 1\n    def update(self, obj):\n        if Controller.getJoystickDirection() == DIR_LEFT:\n            obj.velocity -= self.WALK_ACCELERATION",
        "detail": "component",
        "documentation": {}
    },
    {
        "label": "PlayerInputComponent",
        "kind": 6,
        "importPath": "component",
        "description": "component",
        "peekOfCode": "class PlayerInputComponent(InputComponent):\n    def __init__(self) -> None:\n        self.WALK_ACCELERATION = 1\n    def update(self, obj):\n        if Controller.getJoystickDirection() == DIR_LEFT:\n            obj.velocity -= self.WALK_ACCELERATION\n        elif Controller.getJoystickDirection() == DIR_RIGHT:\n            obj.velocity += self.WALK_ACCELERATION\nclass DemoInputComponent(InputComponent):\n    # AI to automatically control Bjorn",
        "detail": "component",
        "documentation": {}
    },
    {
        "label": "DemoInputComponent",
        "kind": 6,
        "importPath": "component",
        "description": "component",
        "peekOfCode": "class DemoInputComponent(InputComponent):\n    # AI to automatically control Bjorn\n    def update(self, obj):\n        pass\nclass PhysicsComponent(ABC):\n    @abstractmethod\n    def update(self, obj, world):\n        pass\nclass BjornPhysicsComponent(PhysicsComponent):\n    def __init__(self, volume) -> None:",
        "detail": "component",
        "documentation": {}
    },
    {
        "label": "PhysicsComponent",
        "kind": 6,
        "importPath": "component",
        "description": "component",
        "peekOfCode": "class PhysicsComponent(ABC):\n    @abstractmethod\n    def update(self, obj, world):\n        pass\nclass BjornPhysicsComponent(PhysicsComponent):\n    def __init__(self, volume) -> None:\n        self.volume = volume\n    def update(self, obj, world):\n        obj.x += obj.velocity\n        world.resolveCollision(self.volume, obj.x, obj.y, obj.velocity)",
        "detail": "component",
        "documentation": {}
    },
    {
        "label": "BjornPhysicsComponent",
        "kind": 6,
        "importPath": "component",
        "description": "component",
        "peekOfCode": "class BjornPhysicsComponent(PhysicsComponent):\n    def __init__(self, volume) -> None:\n        self.volume = volume\n    def update(self, obj, world):\n        obj.x += obj.velocity\n        world.resolveCollision(self.volume, obj.x, obj.y, obj.velocity)\nclass GraphicsComponent:\n    def update(self, obj, graphics):\n        pass\nclass BjornGraphicsComponent(GraphicsComponent):",
        "detail": "component",
        "documentation": {}
    },
    {
        "label": "GraphicsComponent",
        "kind": 6,
        "importPath": "component",
        "description": "component",
        "peekOfCode": "class GraphicsComponent:\n    def update(self, obj, graphics):\n        pass\nclass BjornGraphicsComponent(GraphicsComponent):\n    def __init__(self, spriteStand, spriteWalkLeft, spriteWalkRight) -> None:\n        self.spriteStand = spriteStand\n        self.spriteWalkLeft = spriteWalkLeft\n        self.spriteWalkRight = spriteWalkRight\n    def update(self, obj, graphics):\n        if obj.velocity < 0:",
        "detail": "component",
        "documentation": {}
    },
    {
        "label": "BjornGraphicsComponent",
        "kind": 6,
        "importPath": "component",
        "description": "component",
        "peekOfCode": "class BjornGraphicsComponent(GraphicsComponent):\n    def __init__(self, spriteStand, spriteWalkLeft, spriteWalkRight) -> None:\n        self.spriteStand = spriteStand\n        self.spriteWalkLeft = spriteWalkLeft\n        self.spriteWalkRight = spriteWalkRight\n    def update(self, obj, graphics):\n        if obj.velocity < 0:\n            sprite = self.spriteWalkLeft\n        elif obj.velocity > 0:\n            sprite = self.spriteWalkRight",
        "detail": "component",
        "documentation": {}
    },
    {
        "label": "GameObject",
        "kind": 6,
        "importPath": "component",
        "description": "component",
        "peekOfCode": "class GameObject:\n    def __init__(self, input, physics, graphics):\n        self.velocity = 0\n        self.x = 0\n        self.y = 0\n        self.input = input\n        self.physics = physics\n        self.graphics = graphics\n    def update(self, world, graphics):\n        self.input.update(self)",
        "detail": "component",
        "documentation": {}
    },
    {
        "label": "createBjorn",
        "kind": 2,
        "importPath": "component",
        "description": "component",
        "peekOfCode": "def createBjorn():\n    return GameObject(PlayerInputComponent(), \n                        BjornPhysicsComponent(), \n                        BjornGraphicsComponent())\n\"\"\"\nUser inputcomponent that has method using Character as input to update the Character\nUpdate the inputcomponent inside the Character update method\nThe Character own the inputcomponent that control the Character velocity by a specific acceleration stored inside inputcomponent\nThe character also own a physicscomponent that change the Character position according to its velocity and world.resolve collision function with the character and world as input\nThe character also own a graphicscomponent that points to left if velocity lower than 0 else right and graphic.draw function with character and graphics as input",
        "detail": "component",
        "documentation": {}
    },
    {
        "label": "VerbFormError",
        "kind": 2,
        "importPath": "error",
        "description": "error",
        "peekOfCode": "def VerbFormError(tags):\n    if tags[2].startswith('V') and tags[2] != 'VB':\n        if tags[1] == 'MD' or tags [1] == 'TO':\n            return True\n        elif tags[0] == 'MD' or tags [0] == 'TO':\n            return True\n        else:\n            return False\n    else:\n        return False",
        "detail": "error",
        "documentation": {}
    },
    {
        "label": "SubjectVerbAgreementError",
        "kind": 2,
        "importPath": "error",
        "description": "error",
        "peekOfCode": "def SubjectVerbAgreementError(tags):\n    if tags[2].startswith('V') and tags[2] == 'VBP':\n        if tags[1] == 'NN' or tags [1] == 'NNP':\n            return True\n        elif tags[0] == 'NN' or tags [0] == 'NNP':\n            return True\n        else:\n            return False\n    elif tags[2].startswith('V') and tags[2] == 'VBZ':\n        if tags[1] == 'NNS' or tags [1] == 'NNPS':",
        "detail": "error",
        "documentation": {}
    },
    {
        "label": "Survivor",
        "kind": 6,
        "importPath": "genetic",
        "description": "genetic",
        "peekOfCode": "class Survivor:\n    def __init__(self, behavior_params):\n        self.behavior_params = behavior_params\n    def update(self, game_state):\n        # Update the Survivor's behavior based on the game state and the behavior parameters\n        pass\n# Define the behavior parameters for the initial population of students\ninitial_pop = [\n    {\n        'movement_pattern': 'random_walk',",
        "detail": "genetic",
        "documentation": {}
    },
    {
        "label": "GeneticAlgorithm",
        "kind": 6,
        "importPath": "genetic",
        "description": "genetic",
        "peekOfCode": "class GeneticAlgorithm(object):\n    def __init__(self, genetics):\n        self.genetics = genetics\n    def run(self):\n        population = self.genetics.initial()\n        while True:\n            fitness_value_dict = [(self.genetics.fitness(chromosome),  chromosome) for chromosome in population]\n            if self.genetics.check_stop(fitness_value_dict): break\n            population = self.update_population(fitness_value_dict)\n        return population",
        "detail": "genetic",
        "documentation": {}
    },
    {
        "label": "GeneticFunctions",
        "kind": 6,
        "importPath": "genetic",
        "description": "genetic",
        "peekOfCode": "class GeneticFunctions(object):\n    def probability_crossover(self):\n        r\"\"\"returns rate of occur crossover(0.0-1.0)\"\"\"\n        return 1.0\n    def probability_mutation(self):\n        r\"\"\"returns rate of occur mutation(0.0-1.0)\"\"\"\n        return 0.0\n    def initial(self):\n        r\"\"\"returns list of initial population\n        \"\"\"",
        "detail": "genetic",
        "documentation": {}
    },
    {
        "label": "MovementControl",
        "kind": 6,
        "importPath": "genetic",
        "description": "genetic",
        "peekOfCode": "class MovementControl(GeneticFunctions):\n    def __init__(self, map, person_pos, zombie_positions,\n                 limit=450, size=400,\n                 prob_crossover=0.9, prob_mutation=0.2):\n        self.map = map\n        self.person_pos = person_pos\n        self.zombie_positions = zombie_positions\n        self.counter = 0\n        self.limit = limit\n        self.size = size",
        "detail": "genetic",
        "documentation": {}
    },
    {
        "label": "fitness",
        "kind": 2,
        "importPath": "genetic",
        "description": "genetic",
        "peekOfCode": "def fitness(survivor, game_state):\n    # Evaluate the Survivor's behavior based on the game state and return a score\n    score = 0\n    # Calculate the Survivor's survival time\n    survival_time = game_state['time'] - survivor.time_of_death\n    if survivor.is_alive:\n        survival_time += 1\n    score += survival_time\n    # Add points for each enemy defeated\n    score += survivor.enemies_defeated",
        "detail": "genetic",
        "documentation": {}
    },
    {
        "label": "initial_pop",
        "kind": 5,
        "importPath": "genetic",
        "description": "genetic",
        "peekOfCode": "initial_pop = [\n    {\n        'movement_pattern': 'random_walk',\n        'decision_making_rule': 'flee_from_zombies',\n        'response_to_player': 'follow'\n    },\n    {\n        'movement_pattern': 'follow_player',\n        'decision_making_rule': 'attack_zombies',\n        'response_to_player': 'help'",
        "detail": "genetic",
        "documentation": {}
    },
    {
        "label": "pop",
        "kind": 5,
        "importPath": "genetic",
        "description": "genetic",
        "peekOfCode": "pop = [Student(behavior_params) for behavior_params in initial_pop]\ndef fitness(survivor, game_state):\n    # Evaluate the Survivor's behavior based on the game state and return a score\n    score = 0\n    # Calculate the Survivor's survival time\n    survival_time = game_state['time'] - survivor.time_of_death\n    if survivor.is_alive:\n        survival_time += 1\n    score += survival_time\n    # Add points for each enemy defeated",
        "detail": "genetic",
        "documentation": {}
    },
    {
        "label": "initial_pop",
        "kind": 5,
        "importPath": "genetic",
        "description": "genetic",
        "peekOfCode": "initial_pop = [Survivor({'movement_pattern': 'random', 'decision_making_rule': 'attack_weakest'}),\n              Survivor({'movement_pattern': 'follow_player', 'decision_making_rule': 'run_away'}),\n              Survivor({'movement_pattern': 'stationary', 'decision_making_rule': 'attack_nearest'})]\n# Define the game state\ngame_state = {'time': 0, 'players': [], 'zombies': []}\nfor i in range(1000):\n    # Update the game state\n    game_state = update_game_state()\n    # Update the student behaviors\n    for student in pop:",
        "detail": "genetic",
        "documentation": {}
    },
    {
        "label": "game_state",
        "kind": 5,
        "importPath": "genetic",
        "description": "genetic",
        "peekOfCode": "game_state = {'time': 0, 'players': [], 'zombies': []}\nfor i in range(1000):\n    # Update the game state\n    game_state = update_game_state()\n    # Update the student behaviors\n    for student in pop:\n        student.update(game_state)\n    # Evolve the student population\n    pop = evolve(pop, game_state)\n\"\"\"",
        "detail": "genetic",
        "documentation": {}
    },
    {
        "label": "control",
        "kind": 5,
        "importPath": "genetic",
        "description": "genetic",
        "peekOfCode": "control = MovementControl(map, person_pos, zombie_positions, limit=1000, size=200, prob_crossover=0.9, prob_mutation=0.2)\n# create an instance of the GeneticAlgorithm class\nga = GeneticAlgorithm(control)\n# run the genetic algorithm\nbest = ga.run()[0]\n# print the best solution found by the genetic algorithm\nprint(best)\n\"\"\"\nThe MovementControl class takes the following arguments in its __init__ method:\nmap: a 2D array representing the map of the simulation",
        "detail": "genetic",
        "documentation": {}
    },
    {
        "label": "ga",
        "kind": 5,
        "importPath": "genetic",
        "description": "genetic",
        "peekOfCode": "ga = GeneticAlgorithm(control)\n# run the genetic algorithm\nbest = ga.run()[0]\n# print the best solution found by the genetic algorithm\nprint(best)\n\"\"\"\nThe MovementControl class takes the following arguments in its __init__ method:\nmap: a 2D array representing the map of the simulation\nperson_pos: a tuple with the position (x, y) of the person on the map\nzombie_positions: a list of tuples with the positions (x, y) of the zombies on the map",
        "detail": "genetic",
        "documentation": {}
    },
    {
        "label": "best",
        "kind": 5,
        "importPath": "genetic",
        "description": "genetic",
        "peekOfCode": "best = ga.run()[0]\n# print the best solution found by the genetic algorithm\nprint(best)\n\"\"\"\nThe MovementControl class takes the following arguments in its __init__ method:\nmap: a 2D array representing the map of the simulation\nperson_pos: a tuple with the position (x, y) of the person on the map\nzombie_positions: a list of tuples with the positions (x, y) of the zombies on the map\nlimit: an integer representing the maximum number of iterations the genetic algorithm will run\nsize: an integer representing the size of the population (number of chromosomes in each generation)",
        "detail": "genetic",
        "documentation": {}
    },
    {
        "label": "Human",
        "kind": 6,
        "importPath": "human",
        "description": "human",
        "peekOfCode": "class Human:\n    def __init__(self, id, position, health, strength, armour, speed, intelligence):\n        self.id = id\n        self.position = position\n        self.health = health\n        self.strength = strength\n        self.armour = armour\n        self.speed = speed\n        self.intelligence = intelligence\n        self.inventory = []",
        "detail": "human",
        "documentation": {}
    },
    {
        "label": "Weapon",
        "kind": 6,
        "importPath": "human",
        "description": "human",
        "peekOfCode": "class Weapon:\n    location: tuple\n    damage: int\n@dataclass\nclass PowerUp:\n    location: tuple\n    health: int\n    strength: int\n    armour: int\n    speed: int",
        "detail": "human",
        "documentation": {}
    },
    {
        "label": "PowerUp",
        "kind": 6,
        "importPath": "human",
        "description": "human",
        "peekOfCode": "class PowerUp:\n    location: tuple\n    health: int\n    strength: int\n    armour: int\n    speed: int\n    intelligence: int\nclass Zombie:\n    def __init__(self, id, position, health, strength, speed, armour, intelligence):\n        self.id = id",
        "detail": "human",
        "documentation": {}
    },
    {
        "label": "Zombie",
        "kind": 6,
        "importPath": "human",
        "description": "human",
        "peekOfCode": "class Zombie:\n    def __init__(self, id, position, health, strength, speed, armour, intelligence):\n        self.id = id\n        self.position = position\n        self.health = health\n        self.strength = strength\n        self.speed = speed\n        self.armour = armour\n        self.intelligence = intelligence\n    @property",
        "detail": "human",
        "documentation": {}
    },
    {
        "label": "Environment",
        "kind": 6,
        "importPath": "human",
        "description": "human",
        "peekOfCode": "class Environment:\n    def __init__(self, m, n, item):\n        self.grid = [[None for _ in range(m)] for _ in range(n)] # 2D list of None (empty), Human, Zombie\n        # list of randomly assigned location of human\n        self.humans = [(random.randint(0, m-1), random.randint(0, n-1)) for _ in range(10)]\n        # list of randomly assigned location of zombie\n        self.zombies = [(random.randint(0, m-1), random.randint(0, n-1)) for _ in range(10)]\n        self.item = item # list of location of weapon, power-up, other resources\n    def get_item(self, location):\n        if location in self.item:",
        "detail": "human",
        "documentation": {}
    },
    {
        "label": "Simulation",
        "kind": 6,
        "importPath": "human",
        "description": "human",
        "peekOfCode": "class Simulation:\n    def __init__(self, m, n, item):\n        self.env = Environment(m, n, item)\n    def run(self):\n        # update\n        # print\n        pass\n    def plot(self):\n        pass\n## Advanced",
        "detail": "human",
        "documentation": {}
    },
    {
        "label": "\tneighbors",
        "kind": 5,
        "importPath": "human",
        "description": "human",
        "peekOfCode": "\tneighbors = self.get_neighbors(agent)\n\tif isinstance(agent, Human):\n\t\tfor neighbor in neighbors:\n\t\t\tif isinstance(neighbor, Zombie):\n\t\t\t\treturn \"attack\"\n\t\treturn \"move\"\n\telif isinstance(agent, Zombie):\n\t\tfor neighbor in neighbors:\n\t\t\tif isinstance(neighbor, Human):\n\t\t\t\treturn \"attack\"",
        "detail": "human",
        "documentation": {}
    },
    {
        "label": "\tneighbors",
        "kind": 5,
        "importPath": "human",
        "description": "human",
        "peekOfCode": "\tneighbors = self.get_neighbors(agent)\n\tif isinstance(agent, Human):\n\t\tfor neighbor in neighbors:\n\t\t\tif isinstance(neighbor, Zombie):\n\t\t\t\treturn \"attack\"\n\t\treturn \"move\"\n\telif isinstance(agent, Zombie):\n\t\tfor neighbor in neighbors:\n\t\t\tif isinstance(neighbor, Human):\n\t\t\t\treturn \"attack\"",
        "detail": "human",
        "documentation": {}
    },
    {
        "label": "\t\t\taction",
        "kind": 5,
        "importPath": "human",
        "description": "human",
        "peekOfCode": "\t\t\taction = self.choose_action(agent)\n\t\t\tif action == \"move\":\n\t\t\t\tdirection = self.choose_direction(agent)\n\t\t\t\tself.move_agent(agent, direction)\n\t\t\telif action == \"attack\":\n\t\t\t\tself.attack_neighbors(agent)\n\t\t\telse:\n\t\t\t\tcontinue\n\t\"\"\"\n    def end_condition(self):",
        "detail": "human",
        "documentation": {}
    },
    {
        "label": "\t\t\t\tdirection",
        "kind": 5,
        "importPath": "human",
        "description": "human",
        "peekOfCode": "\t\t\t\tdirection = self.choose_direction(agent)\n\t\t\t\tself.move_agent(agent, direction)\n\t\t\telif action == \"attack\":\n\t\t\t\tself.attack_neighbors(agent)\n\t\t\telse:\n\t\t\t\tcontinue\n\t\"\"\"\n    def end_condition(self):\n        pass\n    def print_grid(self):",
        "detail": "human",
        "documentation": {}
    },
    {
        "label": "Interpreter",
        "kind": 6,
        "importPath": "interpreter",
        "description": "interpreter",
        "peekOfCode": "class Interpreter:\n    def __init__(self):\n        self.stack = []\n        #存储变量映射关系的字典变量\n        self.environment = {}\n    def STORE_NAME(self, name):\n        val = self.stack.pop()\n        self.environment[name] = val\n    def LOAD_NAME(self, name):\n        val = self.environment[name]",
        "detail": "interpreter",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 2,
        "importPath": "interpreter",
        "description": "interpreter",
        "peekOfCode": "def s():\n    a = 1\n    b = 2\n    print(a + b)\n# Instruction code / code object\nwhat_to_execute = {\n    \"instructions\": [(\"LOAD_VALUE\", 0),\n                    (\"STORE_NAME\", 0),\n                    (\"LOAD_VALUE\", 1),\n                    (\"STORE_NAME\", 1),",
        "detail": "interpreter",
        "documentation": {}
    },
    {
        "label": "what_to_execute",
        "kind": 5,
        "importPath": "interpreter",
        "description": "interpreter",
        "peekOfCode": "what_to_execute = {\n    \"instructions\": [(\"LOAD_VALUE\", 0),\n                    (\"STORE_NAME\", 0),\n                    (\"LOAD_VALUE\", 1),\n                    (\"STORE_NAME\", 1),\n                    (\"LOAD_NAME\", 0),\n                    (\"LOAD_NAME\", 1),\n                    (\"ADD_TWO_VALUES\", None),\n                    (\"PRINT_ANSWER\", None)],\n    \"numbers\": [1, 2],",
        "detail": "interpreter",
        "documentation": {}
    },
    {
        "label": "delay_print",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def delay_print(s,speed=0.05):\n\tglobal stop\n\tif speed==0.05 and speedrun:speed=0\n\tfor c in s:\n\t\tsys.stdout.write(c)\n\t\tsys.stdout.flush()\n\t\ttime.sleep(speed)\n\t\tif stop:\n\t\t\tstop=True\n\t\t\tbreak",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "box_check",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def box_check():\n\tboxes=set()\n\tfor y in range(len(room)):\n\t\tfor x in range(len(room[0])):\n\t\t\tif room[y][x] in range(-8,-4):\n\t\t\t\tboxes.add((x,y))\n\tfor x in boxes:\n\t\tconveyer_box(x[0],x[1])\n# hadles what happens if an error accurs\ndef save():",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "save",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def save():\n\tglobal save_order,save_maze\n\tif not (non or debug):\n\t\tsave={}\n\t\tsave_maze=copy.deepcopy(master_maze)\n\t\tfor y in save_maze:\n\t\t\tfor x in y:\n\t\t\t\t\tx.pop(0)\n\t\tfor x in save_order:\n\t\t\tsave[x]=globals()[x]",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "load",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def load():\n\tglobal xpos,ypos,roomx,roomy,health,oil,bombs,max_health,past_rooms,master_maze\n\tSaveFile=db[name]\n\tfor i in SaveFile:\n\t\tif i=='save_maze':\n\t\t\tsave_maze=SaveFile[i]\n\t\t\tfor y in range(len(master_maze)):\n\t\t\t\t# clear()\n\t\t\t\t# print('['+('#'*y)+(' '*(len(master_maze)-y)+']'))\n\t\t\t\tfor x in range(len(master_maze[y])):",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "refresh",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def refresh():\n\tglobal runery,saving,level_time,health,fire_time,room,state\n\twhile playing:\n\t\trunery-=1\n\t\tif state==\"maze\":\n\t\t\tif level_time<time.time()-150:\n\t\t\t\thealth-=1\n\t\t\t\tlevel_time+=10\n\t\t\t\tif health<=0:\n\t\t\t\t\trespawn()",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "on_error",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def on_error():\n\tglobal roomx,roomy,xpos,ypos,cp\n\tprint(\"An error accured, SUS\")\n\tif speedrun:print(time.time() -start)\n\trespawn()\n# controls the actions the your key preses cause while in the maze\ndef respawn():\n\tglobal xpos,ypos,roomx,roomy,health,maze,room,level_time\n\troomx,roomy,xpos,ypos=cp\n\thealth=3",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "respawn",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def respawn():\n\tglobal xpos,ypos,roomx,roomy,health,maze,room,level_time\n\troomx,roomy,xpos,ypos=cp\n\thealth=3\n\tlevel_time=float('inf')\n\tmaze=master_maze[roomy][roomx]\n\troom=maze[0].get_maze()\n\tfor y in range(len(room)):\n\t\tfor x in range(len(room[0])):\n\t\t\tif room[y][x] in(-2,-9):room[y][x]=0",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "leaderboard",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def leaderboard():\n\tif non:return'Sorry you need an account to see the leaderboard'\n\tlb=db['lb']\n\tdisplay=\"\"\n\tfor x in lb:\n\t\tif not x:display+='-None-\\n'\n\t\telse:display+=f'{x[0]}: {int(x[1]//60)}:{int(x[1]%60)}.{round(x[1]%1*100)}\\n'\n\treturn display\ngetLB=threading.Thread(target=leaderboard)\ndef on_press(key):",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "on_press",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def on_press(key):\n\tglobal xblit,yblit,state,dir,past,char,fire_speed\n\tif key in [keys.UP,\"w\"]:\n\t\tdir=0\n\t\tyblit-=1\n\telif key in [keys.DOWN,\"s\"]:\n\t\tdir=2\n\t\tyblit+=1\n\telif key in [keys.LEFT,\"a\"]:\n\t\tdir=3",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "conveyor",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def conveyor():\n\tglobal xpos,ypos\n\txtest=xpos\n\tytest=ypos\n\tdir=room[ypos][xpos]-13\n\tif dir not in range(4):dir = room[ypos][xpos]+8\n\tif dir not in range(4):return\n\tif dir==0:ytest-=1\n\telif dir==1:xtest+=1\n\telif dir==2:ytest+=1",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "conveyer_box",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def conveyer_box(xpos,ypos):\n\tglobal room\n\tdest=[]\n\troom[ypos][xpos]+=21\n\tif (room[ypos][xpos]-13)==0:\n\t\tdest=[ypos-1,xpos]\n\telif (room[ypos][xpos]-13)==1:\n\t\tdest=[ypos,xpos+1]\n\telif (room[ypos][xpos]-13)==2:\n\t\tdest=[ypos+1,xpos]",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "hotkey",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def hotkey(key):\n\tglobal hotkeys,cursor_pos\n\tif key in hotkeys.keys():return use(hotkeys[key])\n\telse:\n\t\tcursor_pos=0\n\t\twhile True:\n\t\t\tmessage=''\n\t\t\tfor x in range(len(inventory)):\n\t\t\t\tif x==cursor_pos:message+=\"➞ \"\n\t\t\t\telse:message+=\"  \"",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "main_menu",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def main_menu():\n\tglobal cursor_pos,debug,isSave\n\tif non:isSave=False\n\telse:isSave=name in db.keys()\n\tchar=0\n\tkey='None'\n\tif not isSave:cursor_pos+=1\n\twhile True:\n\t\tmessage=''\n\t\tfor x in range(len(startMenu)):",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "use",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def use(item):\n\tglobal inventory,past_rooms,roomx,roomy,xpos,ypos,style,oil,song,darkness,bombs,doubleCost,room,maze,max_health,health\n\tif item=='map':map()\n\telif item==\"goggles\":delay_print(\"Looking through these goggles you can see he trueth\")\n\telif item==\"heart\":\n\t\tmax_health+=1\n\t\thealth=max_health\n\telif item==\"dark\":darkness=not darkness\n\telif item==\"double cost\":doubleCost=not doubleCost\n\telif item==\"up\":",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "run_shop",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def run_shop(shop,key):\n\tglobal money,inventory,oil,cursor_pos,bombs\n\tif key == keys.ESC:return draw_maze()\n\tif key in [keys.ENTER,\"d\",keys.RIGHT]:\n\t\tif cursor_pos==len(shop):\n\t\t\tcursor_pos=0\n\t\t\treturn draw_maze()\n\t\telif shop[cursor_pos][1]<=money and shop[cursor_pos][0] not in inventory:\n\t\t\tmoney -= shop[cursor_pos][1]\n\t\t\tif shop[cursor_pos][0]==\"lamp oil\":",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "menu",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def menu(key=None):\n\tglobal inventory,cursor_pos\n\tif oil>0 and \"lantern\" not in inventory:inventory.append(\"lantern\")\n\tif bombs>0 and \"bombs\" not in inventory:inventory.append(\"bombs\")\n\tif key == keys.ESC: return draw_maze()\n\tif key in (keys.UP,\"w\"):\n\t\tif cursor_pos>0:cursor_pos-=1\n\t\telse:cursor_pos=len(inventory)\n\telif key in (keys.DOWN,\"s\"):\n\t\tif cursor_pos<len(inventory):cursor_pos+=1",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "map",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def map():\n\tglobal roomx,roomy,room,maze\n\tcursorx=roomx\n\tcursory=roomy\n\twhile True:\n\t\tmessage=''\n\t\tfor y in range(len(master_maze)):\n\t\t\tfor x in range(roomx-5,roomx+5):\n\t\t\t\tif x<0 or x>len(master_maze[y])-1:continue\n\t\t\t\tif debug:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "draw_maze",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def draw_maze(message=\"\",death=False):\n\tglobal state,past\n\tstate=\"maze\"\n\tylen=len(room)\n\txlen=len(room[0])\n\tdisplay=\"\"\n\tif level_time<float('inf'):\n\t\tTimeLeft=level_time+150-time.time()\n\t\tif (TimeLeft<60 and TimeLeft%1>.5)or TimeLeft<10:\n\t\t\tdisplay+='\\u001b[31m'",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "update_pos",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def update_pos(xtest,ytest):\n\tglobal xpos,ypos,display,sword\n\txpos=xtest\n\typos=ytest\n\tdisplay=draw_maze(\"ACTIVE\"*debug)\n\tif display:print(display)\n\tsword=False\ndef movement():\n\tglobal xblit,yblit,xpos,ypos,roomy,roomx,runery,inventory,health,state,past_rooms,cp,money,room,maze,cursor_pos,push,playing,saving,speedrun,level_time,fire_time,escape,fire_speed\n\txtest=xpos+xblit",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "movement",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def movement():\n\tglobal xblit,yblit,xpos,ypos,roomy,roomx,runery,inventory,health,state,past_rooms,cp,money,room,maze,cursor_pos,push,playing,saving,speedrun,level_time,fire_time,escape,fire_speed\n\txtest=xpos+xblit\n\tytest=ypos+yblit\n\tylen=len(room)\n\txlen=len(room[0])\n\t# moves the player between rooms\n\tif ytest<0 or ytest>ylen-1 or xtest<0 or xtest>xlen-1:\n\t\tpast_rooms.append([roomx,roomy,xpos,ypos])\n\t\tdir = [ytest>ylen-1,xtest<0,ytest<0,xtest>xlen-1].index(True)",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "\t\tdir",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "\t\tdir = [ytest>ylen-1,xtest<0,ytest<0,xtest>xlen-1].index(True)\n\t\trunery=15\n\t\tif dir==2:roomy-=1\n\t\telif dir==3:roomx+=1\n\t\telif dir==0:roomy+=1\n\t\telif dir==1:roomx-=1\n\t\tmaze=master_maze[roomy][roomx]\n\t\tif not maze[0]:\n\t\t\tif dir==0:roomy-=1\n\t\t\telif dir==1:roomx+=1",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "\tname",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "\tname = input().capitalize()\n\ttime.sleep(0.5)\nmain_menu()\n# start of game\n# delay_print(\"\\nHello I am Mr. Hoisington\")\n# time.sleep(0.5)\n# delay_print('\\nWelcome to my experience')\n# time.sleep(0.5)\nif name in name_responses.keys():\n\tfor x in name_responses[name]:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "\tkey",
        "kind": 5,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "\tkey = getkey()\n\tif state==\"maze\":\n\t\ton_press(key)\n\telif state == \"shop\":\n\t\t# moves the cursor position in the shop\n\t\tif key in (keys.UP,\"w\"):\n\t\t\tif cursor_pos > 0:cursor_pos-=1\n\t\t\telse:cursor_pos=len(shop)\n\t\telif key in (keys.DOWN,\"s\"):\n\t\t\tif cursor_pos < len(shop):cursor_pos+=1",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "maze",
        "kind": 6,
        "importPath": "mazes",
        "description": "mazes",
        "peekOfCode": "class maze:\n\tdef __init__(self,layout,exits=None,name='Maze',time=0,random=None,rand_up=False,end=None):\n\t\tself.layout=layout\n\t\tself.exits=exits\n\t\tself.name=name.capitalize()\n\t\tself.time=time*60\n\t\tself.random=random\n\t\tself.up=rand_up\n\t\tself.end=end\n\tdef get_maze(self):",
        "detail": "mazes",
        "documentation": {}
    },
    {
        "label": "maze",
        "kind": 6,
        "importPath": "pathfinder",
        "description": "pathfinder",
        "peekOfCode": "class maze:\n\tdef __init__(self,layout,exits=None,name='Maze',time=0,random=None,rand_up=False,end=None):\n\t\tself.layout=layout\n\t\tself.exits=exits\n\t\tself.name=name.capitalize()\n\t\tself.time=time*60\n\t\tself.random=random\n\t\tself.up=rand_up\n\t\tself.end=end\n\tdef get_maze(self):",
        "detail": "pathfinder",
        "documentation": {}
    },
    {
        "label": "generate_maze",
        "kind": 2,
        "importPath": "pathfinder",
        "description": "pathfinder",
        "peekOfCode": "def generate_maze(size):\n    maze = [[\"#\" for _ in range(size)] for _ in range(size)]\n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if i == 0 or i == len(maze) - 1 or j == 0 or j == len(maze[0]) - 1:\n                maze[i][j] = \"@\"\n    if random.randint(0, 1) == 0:\n        start = (0, random.randint(1, size-2))\n        exit = (size-1, random.randint(1, size-2))\n    else:",
        "detail": "pathfinder",
        "documentation": {}
    },
    {
        "label": "natural_rendering",
        "kind": 2,
        "importPath": "pathfinder",
        "description": "pathfinder",
        "peekOfCode": "def natural_rendering(size, maze, start, exit):\n    back = [start]\n    pos = start\n    while back:\n        if pos == exit:\n            break\n        choices = []\n        if size-2 >= pos[0] >= 1 and maze[pos[0]-2][pos[1]] == \"#\":\n            choices.append([pos[0]-2, pos[1]])\n        if 0 <= pos[0] <= size-3 and maze[pos[0]+2][pos[1]] == \"#\":",
        "detail": "pathfinder",
        "documentation": {}
    },
    {
        "label": "print_maze",
        "kind": 2,
        "importPath": "pathfinder",
        "description": "pathfinder",
        "peekOfCode": "def print_maze(maze):\n    for row in maze:\n        for cell in row:\n            print(cell, end=\" \")\n        print()\n    print()\n# use the location of the person that find the path\ndef start_location(maze):\n    for row in range(len(maze)):\n        for col in range(len(maze[0])):",
        "detail": "pathfinder",
        "documentation": {}
    },
    {
        "label": "start_location",
        "kind": 2,
        "importPath": "pathfinder",
        "description": "pathfinder",
        "peekOfCode": "def start_location(maze):\n    for row in range(len(maze)):\n        for col in range(len(maze[0])):\n            if maze[row][col] == \"O\":\n                return row, col\n# use the location of the destination\ndef end_location(maze):\n    for row in range(len(maze)):\n        for col in range(len(maze[0])):\n            if maze[row][col] == \"X\":",
        "detail": "pathfinder",
        "documentation": {}
    },
    {
        "label": "end_location",
        "kind": 2,
        "importPath": "pathfinder",
        "description": "pathfinder",
        "peekOfCode": "def end_location(maze):\n    for row in range(len(maze)):\n        for col in range(len(maze[0])):\n            if maze[row][col] == \"X\":\n                return row, col\ndef find_neighbors(maze, row, col):\n    \"\"\"\n    Find the valid neighbors of a given cell.\n    \"\"\"\n    neighbors = []",
        "detail": "pathfinder",
        "documentation": {}
    },
    {
        "label": "find_neighbors",
        "kind": 2,
        "importPath": "pathfinder",
        "description": "pathfinder",
        "peekOfCode": "def find_neighbors(maze, row, col):\n    \"\"\"\n    Find the valid neighbors of a given cell.\n    \"\"\"\n    neighbors = []\n    if row > 0:  # UP\n        neighbors.append((row - 1, col))\n    if row + 1 < len(maze):  # DOWN\n        neighbors.append((row + 1, col))\n    if col > 0:  # LEFT",
        "detail": "pathfinder",
        "documentation": {}
    },
    {
        "label": "find_path",
        "kind": 2,
        "importPath": "pathfinder",
        "description": "pathfinder",
        "peekOfCode": "def find_path(maze, start, end):\n    # Find the shortest path from start to end using the A* algorithm.\n    start_pos = start\n    end_pos = end\n    # priority queue for storing unexplored nodes\n    heap = []\n    heapq.heappush(heap, (0, start_pos, []))\n    visited = set()  # set of visited nodes\n    while heap:\n        cost, current_pos, path = heapq.heappop(heap)",
        "detail": "pathfinder",
        "documentation": {}
    },
    {
        "label": "manhattan_distance",
        "kind": 2,
        "importPath": "pathfinder",
        "description": "pathfinder",
        "peekOfCode": "def manhattan_distance(start, end):\n    x1, y1 = start\n    x2, y2 = end\n    return abs(x1 - x2) + abs(y1 - y2)\n\"\"\"\ndef find_path(maze, start, end):\n    # Find the shortest path from start to end using the A* algorithm.\n    start_pos = start\n    end_pos = end\n    q = queue.Queue()",
        "detail": "pathfinder",
        "documentation": {}
    },
    {
        "label": "find_path",
        "kind": 2,
        "importPath": "pathfinder",
        "description": "pathfinder",
        "peekOfCode": "def find_path(maze, start, end):\n    # Find the shortest path from start to end using the A* algorithm.\n    start_pos = start\n    end_pos = end\n    q = queue.Queue()\n    q.put((start_pos, [start_pos]))\n    visited = set()\n    while not q.empty():\n        current_pos, path = q.get()\n        row, col = current_pos",
        "detail": "pathfinder",
        "documentation": {}
    },
    {
        "label": "print_new_maze",
        "kind": 2,
        "importPath": "pathfinder",
        "description": "pathfinder",
        "peekOfCode": "def print_new_maze(maze, path, start, end):\n    for row in range(len(maze)):\n        for col in range(len(maze[0])):\n            if (row, col) == start:\n                print(\"O\", end=\" \")\n            elif (row, col) == end:\n                print(\"X\", end=\" \")\n            elif (row, col) in path:\n                print(\"o\", end=\" \")\n            else:",
        "detail": "pathfinder",
        "documentation": {}
    },
    {
        "label": "path_finding",
        "kind": 2,
        "importPath": "pathfinder",
        "description": "pathfinder",
        "peekOfCode": "def path_finding():\n    maze, start, exit = generate_maze(10)\n    #start = start_location(maze)\n    #exit = end_location(maze)\n    path = find_path(maze, start, exit)\n    print_maze(maze)\n    print_new_maze(maze, path, start, exit)\npath_finding()\n\"\"\"\nclass maze:",
        "detail": "pathfinder",
        "documentation": {}
    },
    {
        "label": "maze",
        "kind": 5,
        "importPath": "pathfinder",
        "description": "pathfinder",
        "peekOfCode": "maze = [\n    [\"#\", \"O\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\"],\n    [\"#\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"#\"],\n    [\"#\", \" \", \"#\", \"#\", \" \", \"#\", \"#\", \" \", \"#\"],\n    [\"#\", \" \", \"#\", \" \", \" \", \" \", \"#\", \" \", \"#\"],\n    [\"#\", \" \", \"#\", \" \", \"#\", \" \", \"#\", \" \", \"#\"],\n    [\"#\", \" \", \"#\", \" \", \"#\", \" \", \"#\", \" \", \"#\"],\n    [\"#\", \" \", \"#\", \" \", \"#\", \" \", \"#\", \"#\", \"#\"],\n    [\"#\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"#\"],\n    [\"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"#\", \"X\", \"#\"]",
        "detail": "pathfinder",
        "documentation": {}
    },
    {
        "label": "Particle",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class Particle:\n    def __init__(self, pos, vel, acc, mass):\n        self.pos = pos  # 3D position vector\n        self.vel = vel  # 3D velocity vector\n        self.acc = acc  # 3D acceleration vector\n        self.mass = mass  # Scalar mass\n    def update(self, dt):\n        \"\"\"Update the position and velocity of the particle using the Euler method\"\"\"\n        # Update the velocity of the particle\n        self.vel = self.vel + self.acc * dt",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "Circle",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class Circle:\n    def __init__(self, x, y, radius, mass, velocity_x, velocity_y, elasticity):\n        self.x = x\n        self.y = y\n        self.radius = radius\n        self.mass = mass\n        self.velocity_x = velocity_x\n        self.velocity_y = velocity_y\n        self.elasticity = elasticity\n    def handle_collision(self, other_shape):",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class Rectangle:\n    def __init__(self, x, y, width, height, mass, velocity_x, velocity_y, elasticity):\n        self.x = x\n        self.y = y\n        self.width = width\n        self.height = height\n        self.mass = mass\n        self.velocity_x = velocity_x\n        self.velocity_y = velocity_y\n        self.elasticity = elasticity",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "Vector3",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class Vector3:\n    x: float\n    y: float\n    z: float\n# dynamics\n@dataclass\nclass Quaternion:\n    x: float\n    y: float\n    z: float",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "Quaternion",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class Quaternion:\n    x: float\n    y: float\n    z: float\n    w: float\n# Collision detection\n@dataclass\nclass Transform: # describes an objects location and orientation in 3D space\n    Position: Vector3\n    Scale: Vector3",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "Transform",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class Transform: # describes an objects location and orientation in 3D space\n    Position: Vector3\n    Scale: Vector3\n    Rotation: Quaternion\n@dataclass\nclass Object:\n    Position: Vector3\n    Velocity: Vector3\n    Force: Vector3\n    Mass: float",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "Object",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class Object:\n    Position: Vector3\n    Velocity: Vector3\n    Force: Vector3\n    Mass: float\n    Collider: Collider\n    Transform: Transform\n# collision detection\n@dataclass\nclass CollisionPoints:",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "CollisionPoints",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class CollisionPoints:\n    A: Vector3 # furthest point of A into B\n    B: Vector3 # furthest point of B into A\n    Normal: Vector3 # B – A normalized\n    Depth: float # length of B – A\n    HasCollision: bool # true if collision is detected\n# stores the details of a collision between two objects\n@dataclass\nclass Collision:\n    ObjA: Object",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "Collision",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class Collision:\n    ObjA: Object\n    ObjB: Object\n    Points: CollisionPoints\n# collision response\n# solve collisions\nclass Solver:\n    def __init__(self):\n        self.collisions = []\n    def Solve(self, collisions, dt):",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "Solver",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class Solver:\n    def __init__(self):\n        self.collisions = []\n    def Solve(self, collisions, dt):\n        for collision in collisions:\n            # calculate the impulse\n            impulse = self.calculate_impulse(collision, dt)\n            # apply the impulse, friction, restitution, penetration, damping, angular friction, angular restitution, angular penetration, angular damping\n    def calculate_impulse(self, collision, dt):\n        # calculate the velocity of the center of mass",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "PhysicsWorld",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class PhysicsWorld:\n    def __init__(self):\n        self.objects = [] # list of objects\n        self.gravity = Vector3(0., -9.81, 0.) # gravity vector\n    def add_object(self, object):\n        self.objects.append(object)\n    def remove_object(self, object):\n        self.objects.remove(object)\n    # update the position and velocity based on forces acting on it\n    def apply_forces(self, dt):",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "CollisionWorld",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class CollisionWorld(PhysicsWorld):\n    def init(self):\n        super().__init__()\n        self.solvers = [] # List of solvers to use when solving collisions\n        self.callback_on_collision = None # Callback function which will be called when a collision occurs\n    def add_collision_object(self, object):\n        super().add_object(object)\n    def remove_collision_object(self, object):\n        super().remove_object(object)\n    def add_solver(self, solver):",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "SphereCollider",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class SphereCollider:   \n    def __init__(self, Center=None, Radius=None):\n        self.Center = Center\n        self.Radius = Radius\n    def TestCollision(self, transform, collideobject, collideobjectTransform):\n        if isinstance(collideobject, SphereCollider):\n            return algo.FindSphereSphereCollisionPoints(\n                self, transform, collideobject, collideobjectTransform)\n        elif isinstance(collideobject, PlaneCollider):\n            return algo.FindSpherePlaneCollisionPoints(",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "PlaneCollider",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class PlaneCollider:\n    def __init__(self, Plane=None, Distance=None):\n        self.Plane = Plane # Vector3\n        self.Distance = Distance # float\n    def TestCollision(self, transform, collideobject, collideobjectTransform):\n        if isinstance(collideobject, SphereCollider):\n            points = collideobject.TestCollision(collideobjectTransform, self, transform)\n            # swap points because the normal of the plane is pointing outwards\n            T = points.A # You could have an algo Plane v Sphere to do the swap\n            points.A = points.B",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "Collider",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class Collider:\n    def __init__(self, *args, **kwargs):\n        self.sphere_collider = SphereCollider(*args, **kwargs)\n        self.plane_collider = PlaneCollider(*args, **kwargs)\n    def TestCollision(self, transform, collideobject, collideobjectTransform):\n        if isinstance(collideobject, SphereCollider):\n            return self.sphere_collider.TestCollision(transform, collideobject, collideobjectTransform)\n        elif isinstance(collideobject, PlaneCollider):\n            return self.plane_collider.TestCollision(transform, collideobject, collideobjectTransform)\n\"\"\"",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "ColliderFactory",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class ColliderFactory:\n    def create_collider(self, collider_type, **kwargs):\n        if collider_type == \"Sphere\":\n            if 'center' in kwargs and 'radius' in kwargs:\n                return SphereCollider(kwargs['center'], kwargs['radius'])\n        elif collider_type == \"Plane\":\n            if 'plane' in kwargs and 'distance' in kwargs:\n                return PlaneCollider(kwargs['plane'], kwargs['distance'])\n        elif collider_type == \"Collider\":\n            if 'center' in kwargs and 'radius' in kwargs and 'plane' in kwargs and 'distance' in kwargs:",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "algo",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class algo:\n    @staticmethod\n    def FindSphereSphereCollisionPoints(a, ta, b, tb):\n        pass\n    # a = SphereCollider, ta = Transform, b = SphereCollider, tb = Transform\n    @staticmethod\n    def FindSpherePlaneCollisionPoints(a, ta, b, tb):\n        pass\n    # a = SphereCollider, ta = Transform, b = PlaneCollider, tb = Transform\n# more options",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "CollisionObject",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class CollisionObject(object):\n\tdef __init__(self, transform, collider, isTrigger, isDynamic, onCollision):\n\t\tself.m_transform = transform\n\t\tself.m_collider = collider\n\t\tself.m_isTrigger = isTrigger # If the object is a trigger\n\t\tself.m_isDynamic = isDynamic # If the object is dynamic\n\t\tself.m_onCollision = onCollision # Callback function which will be called when the object collides with another object\n    # getters & setters, no setter for m_isDynamic\nclass Rigidbody(CollisionObject):\n    def __init__(self, mass, takesGravity, staticFriction, dynamicFriction, restitution):",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "Rigidbody",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class Rigidbody(CollisionObject):\n    def __init__(self, mass, takesGravity, staticFriction, dynamicFriction, restitution):\n        self.gravity = Vector3(0, -9.81, 0) # Gravitational acceleration\n        self.position = Vector3(0, 0, 0)  \n        self.velocity = Vector3(0, 0, 0) # Velocity of the rigidbody\n        self.force = Vector3(0, 0, 0) # Force applied to the rigidbody\n        self.mass = mass\n        self.takesGravity = takesGravity # If the rigidbody will take gravity from the world.\n        self.m_staticFriction = staticFriction # Static friction coefficient\n        self.m_dynamicFriction = dynamicFriction # Dynamic friction coefficient",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "DynamicsWorld",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class DynamicsWorld(CollisionWorld):\n    def __init__(self):\n        super().__init__()\n        self.m_gravity = Vector3(0, -9.81, 0)\n    def add_rigidbody(self, rigidbody):\n        if rigidbody.takes_gravity():\n            rigidbody.set_gravity(self.m_gravity)\n        self.add_collision_object(rigidbody)\n    def apply_gravity(self):\n        for object in self.objects:",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "CollisionObject",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class CollisionObject:\n    def init(self):\n        self.m_transform = Transform(Position=Vector3(0, 0, 0), Rotation=Quaternion(0, 0, 0, 1), Scale=Vector3(1, 1, 1))\n        self.m_lastTransform = Transform(Position=Vector3(0, 0, 0), Rotation=Quaternion(0, 0, 0, 1), Scale=Vector3(1, 1, 1))\n        self.m_collider = Collider()\n        self.m_isTrigger = False\n        self.m_isStatic = False\n        self.m_isDynamic = False\n        self.m_onCollision = lambda collision, dt: None\n        # getters & setters for everything, no setter for isDynamic",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "PhysicsSmoothStepSystem",
        "kind": 6,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "class PhysicsSmoothStepSystem:\n    def init(self):\n        self.accumulator = 0.0\n    def update(self):\n        for entity in get_all_physics_entities():\n            transform = entity.get(Transform)\n            object = entity.get(CollisionObject)\n            last_transform = object.last_transform()\n            current_transform = object.transform()\n            transform.position = lerp(",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "calculate_forces",
        "kind": 2,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "def calculate_forces(particles):\n    forces = []\n    for particle in particles:\n        force = np.zeros(3)  # 3D force vector\n        # Add any other forces here\n        force += np.array([0, -9.81, 0]) * particle.mass  # Gravity\n        force += np.array([0, 0, 0])  # Other forces\n        forces.append(force)\n    return forces\ndef update_particles(particles, dt, forces):",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "update_particles",
        "kind": 2,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "def update_particles(particles, dt, forces):\n    for i in range(len(particles)):\n        # Update the acceleration of the particle based on the forces acting on it\n        particles[i].acc = forces[i] / particles[i].mass\n        # Update the position and velocity of the particle using the Euler method\n        particles[i].update(dt)\ndef simulate(particles, dt):\n    # Calculate the forces acting on each particle\n    forces = calculate_forces(particles)\n    # Update the position, velocity and acceleration of each particle",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "simulate",
        "kind": 2,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "def simulate(particles, dt):\n    # Calculate the forces acting on each particle\n    forces = calculate_forces(particles)\n    # Update the position, velocity and acceleration of each particle\n    update_particles(particles, dt, forces)\ndef display(particles, t):\n    \"\"\"Display the current state of the simulation\"\"\"\n    print(\"Time: {}\".format(t))\n    for particle in particles:\n        print(\"Position: {}\".format(particle.pos))",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "display",
        "kind": 2,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "def display(particles, t):\n    \"\"\"Display the current state of the simulation\"\"\"\n    print(\"Time: {}\".format(t))\n    for particle in particles:\n        print(\"Position: {}\".format(particle.pos))\n        print(\"Velocity: {}\".format(particle.vel))\n        print(\"Acceleration: {}\".format(particle.acc))\n        print(\"Mass: {}\".format(particle.mass))\n        print(\"\")\n    print(\"\")",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "dynamic",
        "kind": 2,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "def dynamic():\n    # Set up the simulation\n    dt = 0.01  # Time step\n    t = 0  # Current time\n    t_max = 10  # Maximum time\n    # Create a list of particles\n    particles = [Particle(np.array([0, 0, 0]), np.array([1, 1, 1]), np.array([0, 0, 0]), 1),\n                Particle(np.array([1, 1, 1]), np.array([0, 0, 0]), np.array([0, 0, 0]), 2)]\n    # Simulate the particles for a fixed amount of time\n    while t < t_max:",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "detect_collision",
        "kind": 2,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "def detect_collision(shape1, shape2):\n    if isinstance(shape1, Circle) and isinstance(shape2, Circle):\n        # Calculate the distance between the two centers\n        dx = shape1.x - shape2.x\n        dy = shape1.y - shape2.y\n        distance = math.sqrt(dx**2 + dy**2)\n        # Check if the distance is smaller than the sum of the radii\n        if distance < shape1.radius + shape2.radius:\n            return True\n        else:",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "line_intersect_circle",
        "kind": 2,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "def line_intersect_circle(x1, y1, x2, y2, cx, cy, radius):\n    # Check if the line is horizontal\n    if y1 == y2:\n        # Check if the circle is above or below the line\n        if (cy < y1 and cy + radius < y1) or (cy > y1 and cy - radius > y1):\n            return False\n        else:\n            # Check if the circle intersects the line\n            if (cx < x1 and cx + radius < x1) or (cx > x2 and cx - radius > x2):\n                return False",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "handle_collision",
        "kind": 2,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "def handle_collision(shape1, shape2):\n    # Determine the collision normal\n    normal = (0, 0)\n    # Initialise the distance to 0\n    distance = 0\n    if isinstance(shape1, Circle) and isinstance(shape2, Circle):\n        # Calculate the collision normal as the unit vector pointing from the center of shape1 to the center of shape2\n        dx = shape2.x - shape1.x\n        dy = shape2.y - shape1.y\n        distance = math.sqrt(dx**2 + dy**2)",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "calculate_new_velocity",
        "kind": 2,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "def calculate_new_velocity(mass1, elasticity1, v1x, v1y, mass2, elasticity2, v2x, v2y, normal):\n    # Calculate the velocity of the center of mass\n    v_cm_x = (mass1 * v1x + mass2 * v2x) / (mass1 + mass2)\n    v_cm_y = (mass1 * v1y + mass2 * v2y) / (mass1 + mass2)\n    # Calculate the relative velocity of the objects\n    v_rel_x = v1x - v2x\n    v_rel_y = v1y - v2y\n    # Calculate the component of the relative velocity along the collision normal\n    v_rel_normal = v_rel_x * normal[0] + v_rel_y * normal[1]\n    # Calculate the new relative velocity",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "collision",
        "kind": 2,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "def collision():\n    # Define the shapes\n    shape1 = Circle(0, 0, 10, 0, 0, 1, 1)\n    shape2 = Circle(30, 0, 10, 0, 0, 1, 1)\n    # Check for a collision and handle it if one is detected\n    if detect_collision(shape1, shape2):\n        handle_collision(shape1, shape2)\n    # Define the shapes\n    shape1 = Rectangle(0, 0, 20, 20, 0, 0, 1, 1)\n    shape2 = Rectangle(30, 0, 20, 20, 0, 0, 1, 1)",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "factory",
        "kind": 5,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "factory = ColliderFactory()\ncollider = factory.create_collider(\"Sphere\", center=[0,0,0], radius=1)\n\"\"\"\n# the algo namespace includes two static methods for finding the collision points between a sphere and another sphere or a plane\n# take as input the SphereCollider and PlaneCollider objects being tested, as well as their corresponding Transform objects, and return a CollisionPoints object indicating the details of the collision.\nclass algo:\n    @staticmethod\n    def FindSphereSphereCollisionPoints(a, ta, b, tb):\n        pass\n    # a = SphereCollider, ta = Transform, b = SphereCollider, tb = Transform",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "collider",
        "kind": 5,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "collider = factory.create_collider(\"Sphere\", center=[0,0,0], radius=1)\n\"\"\"\n# the algo namespace includes two static methods for finding the collision points between a sphere and another sphere or a plane\n# take as input the SphereCollider and PlaneCollider objects being tested, as well as their corresponding Transform objects, and return a CollisionPoints object indicating the details of the collision.\nclass algo:\n    @staticmethod\n    def FindSphereSphereCollisionPoints(a, ta, b, tb):\n        pass\n    # a = SphereCollider, ta = Transform, b = SphereCollider, tb = Transform\n    @staticmethod",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "\t\tself.m_transform",
        "kind": 5,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "\t\tself.m_transform = transform\n\t\tself.m_collider = collider\n\t\tself.m_isTrigger = isTrigger # If the object is a trigger\n\t\tself.m_isDynamic = isDynamic # If the object is dynamic\n\t\tself.m_onCollision = onCollision # Callback function which will be called when the object collides with another object\n    # getters & setters, no setter for m_isDynamic\nclass Rigidbody(CollisionObject):\n    def __init__(self, mass, takesGravity, staticFriction, dynamicFriction, restitution):\n        self.gravity = Vector3(0, -9.81, 0) # Gravitational acceleration\n        self.position = Vector3(0, 0, 0)  ",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "\t\tself.m_collider",
        "kind": 5,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "\t\tself.m_collider = collider\n\t\tself.m_isTrigger = isTrigger # If the object is a trigger\n\t\tself.m_isDynamic = isDynamic # If the object is dynamic\n\t\tself.m_onCollision = onCollision # Callback function which will be called when the object collides with another object\n    # getters & setters, no setter for m_isDynamic\nclass Rigidbody(CollisionObject):\n    def __init__(self, mass, takesGravity, staticFriction, dynamicFriction, restitution):\n        self.gravity = Vector3(0, -9.81, 0) # Gravitational acceleration\n        self.position = Vector3(0, 0, 0)  \n        self.velocity = Vector3(0, 0, 0) # Velocity of the rigidbody",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "\t\tself.m_isTrigger",
        "kind": 5,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "\t\tself.m_isTrigger = isTrigger # If the object is a trigger\n\t\tself.m_isDynamic = isDynamic # If the object is dynamic\n\t\tself.m_onCollision = onCollision # Callback function which will be called when the object collides with another object\n    # getters & setters, no setter for m_isDynamic\nclass Rigidbody(CollisionObject):\n    def __init__(self, mass, takesGravity, staticFriction, dynamicFriction, restitution):\n        self.gravity = Vector3(0, -9.81, 0) # Gravitational acceleration\n        self.position = Vector3(0, 0, 0)  \n        self.velocity = Vector3(0, 0, 0) # Velocity of the rigidbody\n        self.force = Vector3(0, 0, 0) # Force applied to the rigidbody",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "\t\tself.m_isDynamic",
        "kind": 5,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "\t\tself.m_isDynamic = isDynamic # If the object is dynamic\n\t\tself.m_onCollision = onCollision # Callback function which will be called when the object collides with another object\n    # getters & setters, no setter for m_isDynamic\nclass Rigidbody(CollisionObject):\n    def __init__(self, mass, takesGravity, staticFriction, dynamicFriction, restitution):\n        self.gravity = Vector3(0, -9.81, 0) # Gravitational acceleration\n        self.position = Vector3(0, 0, 0)  \n        self.velocity = Vector3(0, 0, 0) # Velocity of the rigidbody\n        self.force = Vector3(0, 0, 0) # Force applied to the rigidbody\n        self.mass = mass",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "\t\tself.m_onCollision",
        "kind": 5,
        "importPath": "physics_engine",
        "description": "physics_engine",
        "peekOfCode": "\t\tself.m_onCollision = onCollision # Callback function which will be called when the object collides with another object\n    # getters & setters, no setter for m_isDynamic\nclass Rigidbody(CollisionObject):\n    def __init__(self, mass, takesGravity, staticFriction, dynamicFriction, restitution):\n        self.gravity = Vector3(0, -9.81, 0) # Gravitational acceleration\n        self.position = Vector3(0, 0, 0)  \n        self.velocity = Vector3(0, 0, 0) # Velocity of the rigidbody\n        self.force = Vector3(0, 0, 0) # Force applied to the rigidbody\n        self.mass = mass\n        self.takesGravity = takesGravity # If the rigidbody will take gravity from the world.",
        "detail": "physics_engine",
        "documentation": {}
    },
    {
        "label": "PickleStorage",
        "kind": 6,
        "importPath": "pickle_storage",
        "description": "pickle_storage",
        "peekOfCode": "class PickleStorage(object):\n    def __init__(self, filename):\n        self.filename = filename\n    def save(self, data):\n        with open(self.filename, 'wb') as f:\n            pickle.dump(data, f)\n    def load(self):\n        with open(self.filename, 'rb') as f:\n            return pickle.load(f)\n# example code to manupilate a data structure",
        "detail": "pickle_storage",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "pickle_storage",
        "description": "pickle_storage",
        "peekOfCode": "data = PickleStorage('data.pickle').load()\n# do something with data\nPickleStorage('data.pickle').save(data)",
        "detail": "pickle_storage",
        "documentation": {}
    },
    {
        "label": "State",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class State(Enum):\n    HEALTHY = auto()\n    INFECTED = auto()\n    ZOMBIE = auto()\n    DEAD = auto()\n    @classmethod\n    def name_list(cls) -> list[str]:\n        return [enm.name for enm in State]\n    @classmethod\n    def value_list(cls) -> list[int]:",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "MovementStrategy",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class MovementStrategy(ABC):\n    individual: Any[Individual]\n    legal_directions: list[tuple[int, int]]\n    neighbors: list[Individual]\n    @abstractmethod\n    def choose_direction(self, individual, school):\n        raise NotImplementedError\n@dataclass\n# if no neighbors, choose random direction\nclass RandomMovementStrategy(MovementStrategy):",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "RandomMovementStrategy",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class RandomMovementStrategy(MovementStrategy):\n    individual: Any[Individual]\n    legal_directions: list[tuple[int, int]]\n    neighbors: list[Individual]\n    def choose_direction(self):\n        return random.choice(self.legal_directions)\n@dataclass\n# if healthy or other having no alive neighbors\nclass FleeZombiesStrategy(MovementStrategy):\n    individual: Any[Individual]",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "FleeZombiesStrategy",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class FleeZombiesStrategy(MovementStrategy):\n    individual: Any[Individual]\n    legal_directions: list[tuple[int, int]]\n    neighbors: list[Individual]\n    def choose_direction(self):\n        zombies_locations = [zombies.location for zombies in self.neighbors if zombies.state == State.ZOMBIE]\n        return self.direction_against_closest(self.individual, self.legal_directions, zombies_locations)\n    # find the closest zombie and move away from it\n    def direction_against_closest(self, individual: Individual, legal_directions: list[tuple[int, int]], target_locations: list[tuple[int, int]]) -> tuple[int, int]:\n        new_locations = [tuple(np.add(individual.location, direction))",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "ChaseHumansStrategy",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class ChaseHumansStrategy(MovementStrategy):\n    individual: Any[Individual]\n    legal_directions: list[tuple[int, int]]\n    neighbors: list[Individual]\n    def choose_direction(self):\n        alive_locations = [alive.location for alive in self.neighbors if alive.state == State.HEALTHY]\n        return self.direction_towards_closest(self.individual, self.legal_directions, alive_locations)\n    # find the closest human and move towards it\n    def direction_towards_closest(self, individual: Individual, legal_directions: list[tuple[int, int]], target_locations: list[tuple[int, int]]) -> tuple[int, int]:\n        new_locations = [tuple(np.add(individual.location, direction))",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "NoMovementStrategy",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class NoMovementStrategy(MovementStrategy):\n    individual: Any[Individual]\n    legal_directions: list[tuple[int, int]]\n    neighbors: list[Individual]\n    def choose_direction(self):\n        return (0, 0)\n# may use init to store individual and school\n# may use function, use closure to store individual and school\nclass MovementStrategyFactory:\n    def create_strategy(self, individual, school):",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "MovementStrategyFactory",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class MovementStrategyFactory:\n    def create_strategy(self, individual, school):\n        # get legal directions\n        legal_directions = school.get_legal_directions(individual)\n        # get neighbors\n        neighbors = school.get_neighbors(individual.location, individual.sight_range)\n        # early exit\n        # if no neighbors, random movement\n        if not neighbors:\n            return RandomMovementStrategy(individual, legal_directions, neighbors)",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "Individual",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class Individual:\n    __slots__ = \"id\", \"state\", \"location\", \"connections\", \\\n        \"infection_severity\", \"interact_range\", \"__dict__\"\n    def __init__(self, id: int, state: State, location: tuple[int, int], movement_strategy: Any[MovementStrategy] = RandomMovementStrategy) -> None:\n        self.id: int = id\n        self.state: State = state\n        self.location: tuple[int, int] = location\n        self.connections: list[Individual] = []\n        self.infection_severity: float = 0.0\n        self.interact_range: int = 2",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "StateMachine",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class StateMachine(ABC):\n    def __init__(self, context: Individual) -> None:\n        self.context = context\n    @abstractmethod\n    def update_state(self, severity: float) -> None:\n        pass\n    def is_infected(self, context: Individual, severity: float) -> bool:\n        infection_probability = 1 / (1 + math.exp(-severity))\n        for other in context.connections:\n            if other.state == State.ZOMBIE:",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "HealthyMachine",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class HealthyMachine(StateMachine):\n    # cellular automaton\n    def update_state(self, severity: float) -> None:\n        if self.is_infected(self.context, severity):\n            self.context.state = State.INFECTED\n    # probability = severity / school.max_severity\n    # probability *= 1 - math.exp(-self.interaction_duration/average_interaction_duration_for_infection)\n    # probability *= 1 - math.exp(-distance / average_distance_for_infection)\nclass InfectedMachine(StateMachine):\n    # cellular automaton",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "InfectedMachine",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class InfectedMachine(StateMachine):\n    # cellular automaton\n    def update_state(self, severity: float) -> None:\n        self.context.infection_severity += 0.1\n        if self.is_turned(self.context, severity):\n            self.context.state = State.ZOMBIE\n        elif self.is_died(self.context, severity):\n            self.context.state = State.DEAD\nclass ZombieMachine(StateMachine):\n    # cellular automaton",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "ZombieMachine",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class ZombieMachine(StateMachine):\n    # cellular automaton\n    def update_state(self, severity: float) -> None:\n        if self.is_died(self.context, severity):\n            self.context.state = State.DEAD\nclass School:\n    __slots__ = \"school_size\", \"grid\", \"strategy_factory\"\n    def __init__(self, school_size: int) -> None:\n        self.school_size = school_size\n        # Create a 2D grid representing the school with each cell can contain a Individual object",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "School",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class School:\n    __slots__ = \"school_size\", \"grid\", \"strategy_factory\"\n    def __init__(self, school_size: int) -> None:\n        self.school_size = school_size\n        # Create a 2D grid representing the school with each cell can contain a Individual object\n        self.grid: list[list[Optional[Individual]]] \\\n            = [[None for _ in range(school_size)]\n                for _ in range(school_size)]\n        self.strategy_factory = MovementStrategyFactory()\n        # may turn to width and height",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "Observer",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class Observer(ABC):\n    @abstractmethod\n    def __init__(self) -> None:\n        pass\n    @abstractmethod\n    def update(self) -> None:\n        pass\n    @abstractmethod\n    def display_observation(self) -> None:\n        pass",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "PopulationObserver",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class PopulationObserver(Observer):\n    def __init__(self, population: Population) -> None:\n        self.subject = population\n        self.subject.attach_observer(self)\n        self.statistics = {}\n        self.agent_list = []\n    def update(self) -> None:\n        self.statistics = self.subject.get_population_statistics()\n        self.agent_list = self.subject.agent_list\n    def display_observation(self, format='text'):",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "SchoolObserver",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class SchoolObserver(Observer):\n    def __init__(self, population: Population) -> None:\n        self.subject = population\n        self.subject.attach_observer(self)\n        self.agent_list = []\n        self.grid = []\n    def update(self) -> None:\n        self.agent_list = self.subject.agent_list\n        self.grid = self.subject.school.grid\n    def display_observation(self, format='text'):",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "Population",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class Population:\n    def __init__(self, school_size: int, population_size: int) -> None:\n        self.school: School = School(school_size)\n        self.agent_list: list[Individual] = []\n        self.severity: float = 0.\n        self.init_population(school_size, population_size)\n        self.update_population_metrics()\n        self.observers = []\n    def add_individual(self, individual: Individual) -> None:\n        self.agent_list.append(individual)",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "Pizza",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class Pizza:\n    def __init__(self):\n        self.dough = \"\"\n        self.sauce = \"\"\n        self.topping = []\n    def set_dough(self, dough):\n        self.dough = dough\n    def set_sauce(self, sauce):\n        self.sauce = sauce\n    def add_topping(self, topping):",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "PizzaBuilder",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class PizzaBuilder(ABC):\n    def __init__(self):\n        self.pizza = Pizza()\n    def create_new_pizza_product(self):\n        self.pizza = Pizza()\n    def get_pizza(self):\n        return self.pizza\n    @abstractmethod\n    def build_dough(self):\n        pass",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "HawaiianPizzaBuilder",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class HawaiianPizzaBuilder(PizzaBuilder):\n    def build_dough(self):\n        self.pizza.set_dough(\"cross\")\n    def build_sauce(self):\n        self.pizza.set_sauce(\"mild\")\n    def build_topping(self):\n        self.pizza.add_topping(\"ham\")\n        self.pizza.add_topping(\"pineapple\")\n# Concrete Builder\nclass SpicyPizzaBuilder(PizzaBuilder):",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "SpicyPizzaBuilder",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class SpicyPizzaBuilder(PizzaBuilder):\n    def build_dough(self):\n        self.pizza.set_dough(\"pan baked\")\n    def build_sauce(self):\n        self.pizza.set_sauce(\"hot\")\n    def build_topping(self):\n        self.pizza.set_topping(\"pepperoni\")\n        self.pizza.set_topping(\"salami\")\n# Director\nclass Waiter:",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "Waiter",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class Waiter:\n    def __init__(self):\n        self.pizza_builder = None\n    def set_pizza_builder(self, pb):\n        self.pizza_builder = pb\n    def get_pizza(self):\n        return self.pizza_builder.get_pizza()\n    def construct_pizza(self):\n        self.pizza_builder.create_new_pizza_product()\n        self.pizza_builder.build_dough()",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "Car",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class Car:\n    def drive(self):\n        print(\"Driving a car.\")\nclass SportsCar(Car):\n    def drive(self):\n        print(\"Driving a sports car at high speed!\")\ncar = SportsCar()\ncar.drive() # \"Driving a sports car at high speed!\"\nThe problem with this approach is that any changes made to the 'drive' method in the 'Car' class will also affect the 'SportsCar' class, as they share the same implementation. Additionally, if we want to add another type of car, we will have to create another subclass and repeat the same process, making the code more complex and less maintainable.\nWthout using the Bridge pattern, we would likely have a single class that contains both the interface and the implementation, making the code tightly coupled and less maintainable. This would mean that any changes made to the implementation would directly affect any references or dependencies on the code.",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "SportsCar",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class SportsCar(Car):\n    def drive(self):\n        print(\"Driving a sports car at high speed!\")\ncar = SportsCar()\ncar.drive() # \"Driving a sports car at high speed!\"\nThe problem with this approach is that any changes made to the 'drive' method in the 'Car' class will also affect the 'SportsCar' class, as they share the same implementation. Additionally, if we want to add another type of car, we will have to create another subclass and repeat the same process, making the code more complex and less maintainable.\nWthout using the Bridge pattern, we would likely have a single class that contains both the interface and the implementation, making the code tightly coupled and less maintainable. This would mean that any changes made to the implementation would directly affect any references or dependencies on the code.\n\"\"\"\n\"\"\"\n/* Implementor interface*/",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "ManualGea",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class ManualGear implements Gear{\n    public void handleGear(){\n        System.out.println(\"Manual gear\");\n    }\n}\n/* Concrete Implementor - 2 */\nclass AutoGear implements Gear{\n    public void handleGear(){\n        System.out.println(\"Auto gear\");\n    }",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "AutoGea",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class AutoGear implements Gear{\n    public void handleGear(){\n        System.out.println(\"Auto gear\");\n    }\n}\n/* Abstraction (abstract class) */\nabstract class Vehicle {\n    Gear gear;\n    public Vehicle(Gear gear){\n        this.gear = gear;",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "Ca",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class Car extends Vehicle{\n    public Car(Gear gear){\n        super(gear);\n        // initialize various other Car components to make the car\n    }\n    public void addGear(){\n        System.out.print(\"Car handles \");\n        gear.handleGear();\n    }\n}",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "Truc",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class Truck extends Vehicle{\n    public Truck(Gear gear){\n        super(gear);\n        // initialize various other Truck components to make the car\n    }\n    public void addGear(){\n        System.out.print(\"Truck handles \" );\n        gear.handleGear();\n    }\n}",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "CarInterface",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class CarInterface(ABC):\n    @abstractmethod\n    def drive(self):\n        pass\n# Abstraction\nclass Car(CarInterface):\n    def __init__(self, implementation):\n        self._implementation = implementation\n    def drive(self):\n        self._implementation.drive()",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "Car",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class Car(CarInterface):\n    def __init__(self, implementation):\n        self._implementation = implementation\n    def drive(self):\n        self._implementation.drive()\n# extra self-defined layer of abstraction\nclass SportsCarInterface:\n    @abstractmethod\n    def drive(self):\n        pass",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "SportsCarInterface",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class SportsCarInterface:\n    @abstractmethod\n    def drive(self):\n        pass\n# Refined Abstraction\nclass SportsCar(Car):\n    pass\n# extra self-defined layer of abstraction\nclass TruckInterface:\n    @abstractmethod",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "SportsCar",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class SportsCar(Car):\n    pass\n# extra self-defined layer of abstraction\nclass TruckInterface:\n    @abstractmethod\n    def drive(self):\n        pass\n# Refined Abstraction\nclass Truck(Car):\n    pass",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "TruckInterface",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class TruckInterface:\n    @abstractmethod\n    def drive(self):\n        pass\n# Refined Abstraction\nclass Truck(Car):\n    pass\n# Concrete Implementor\nclass XSportsCarInterface(SportsCarInterface):\n    def drive(self):",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "Truck",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class Truck(Car):\n    pass\n# Concrete Implementor\nclass XSportsCarInterface(SportsCarInterface):\n    def drive(self):\n        print(\"Driving a sports car from manufacturer X at high speed!\")\n# Concrete Implementor\nclass YSportsCarInterface(SportsCarInterface):\n    def drive(self):\n        print(\"Driving a sports car from manufacturer Y at high speed!\")",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "XSportsCarInterface",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class XSportsCarInterface(SportsCarInterface):\n    def drive(self):\n        print(\"Driving a sports car from manufacturer X at high speed!\")\n# Concrete Implementor\nclass YSportsCarInterface(SportsCarInterface):\n    def drive(self):\n        print(\"Driving a sports car from manufacturer Y at high speed!\")\n# Concrete Implementor\nclass XTruckInterface(TruckInterface):\n    def drive(self):",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "YSportsCarInterface",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class YSportsCarInterface(SportsCarInterface):\n    def drive(self):\n        print(\"Driving a sports car from manufacturer Y at high speed!\")\n# Concrete Implementor\nclass XTruckInterface(TruckInterface):\n    def drive(self):\n        print(\"Driving a truck from manufacturer X at low speed.\")\n# Concrete Implementor\nclass YTruckInterface(TruckInterface):\n    def drive(self):",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "XTruckInterface",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class XTruckInterface(TruckInterface):\n    def drive(self):\n        print(\"Driving a truck from manufacturer X at low speed.\")\n# Concrete Implementor\nclass YTruckInterface(TruckInterface):\n    def drive(self):\n        print(\"Driving a truck from manufacturer Y at low speed.\")\ncar1 = SportsCar(XSportsCarInterface())\ncar2 = SportsCar(YSportsCarInterface())\ncar3 = Truck(XTruckInterface())",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "YTruckInterface",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class YTruckInterface(TruckInterface):\n    def drive(self):\n        print(\"Driving a truck from manufacturer Y at low speed.\")\ncar1 = SportsCar(XSportsCarInterface())\ncar2 = SportsCar(YSportsCarInterface())\ncar3 = Truck(XTruckInterface())\ncar4 = Truck(YTruckInterface())\ncar1.drive() # \"Driving a sports car from manufacturer X at high speed!\"\ncar2.drive() # \"Driving a sports car from manufacturer Y at high speed!\"\ncar3.drive() # \"Driving a truck from manufacturer X at low speed.\"",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "Command",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class Command:\n    def execute(self):\n        raise NotImplementedError\nclass SimpleCommand(Command):\n    def __init__(self, receiver, action):\n        self._receiver = receiver\n        self._action = action\n    def execute(self):\n        self._receiver.do_action(self._action)\nclass Receiver: # perform the actions",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "SimpleCommand",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class SimpleCommand(Command):\n    def __init__(self, receiver, action):\n        self._receiver = receiver\n        self._action = action\n    def execute(self):\n        self._receiver.do_action(self._action)\nclass Receiver: # perform the actions\n    def do_action(self, action):\n        print(f\"Performing action: {action}\")\nclass Invoker: # invokes the action command",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "Receiver",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class Receiver: # perform the actions\n    def do_action(self, action):\n        print(f\"Performing action: {action}\")\nclass Invoker: # invokes the action command\n    def __init__(self):\n        self._commands = []\n    def store_command(self, command):\n        self._commands.append(command)\n    def execute_commands(self):\n        for command in self._commands:",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "Invoker",
        "kind": 6,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "class Invoker: # invokes the action command\n    def __init__(self):\n        self._commands = []\n    def store_command(self, command):\n        self._commands.append(command)\n    def execute_commands(self):\n        for command in self._commands:\n            command.execute()\n# q: what does client do with this?\n# a: Client creates commands and passes them to the invoker",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "def main():\n    # create a SchoolZombieApocalypse object\n    school_sim = Population(school_size=10, population_size=1)\n    # create Observer objects\n    population_observer = PopulationObserver(school_sim)\n    school_observer = SchoolObserver(school_sim)\n    # run the population for a given time period\n    school_sim.run_population(num_time_steps=5)\n    # observe the statistics of the population\n    population_observer.display_observation(format=\"chart\")",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "simulate_movement",
        "kind": 2,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "def simulate_movement(self):\n    for i in range(self.width):\n        for j in range(self.height):\n            individual = self.grid[i][j]\n            if individual is not None:\n                # use the A* algorithm to find the shortest path to the nearest exit\n                start = (i, j)\n                # the four corners of the grid\n                exits = [(0, 0), (0, self.width-1),\n                        (self.height-1, 0), (self.height-1, self.width-1)]",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "a_star",
        "kind": 2,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "def a_star(self, start, goals):\n    # implement the A* algorithm to find the shortest path from the start to one of the goals\n    # returns the distances and previous nodes for each node in the grid\n    pass\ndef reconstruct_path(self, previous, start, goal):\n    # implement the algorithm to reconstruct the path from the previous nodes\n    # returns the shortest path from the start to the goal\n    pass\n\"\"\"\n\"\"\"",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "reconstruct_path",
        "kind": 2,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "def reconstruct_path(self, previous, start, goal):\n    # implement the algorithm to reconstruct the path from the previous nodes\n    # returns the shortest path from the start to the goal\n    pass\n\"\"\"\n\"\"\"\nHigh order function\nhttps://www.youtube.com/watch?v=4B24vYj_vaI\n\"\"\"\n\"\"\"",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "variance",
        "kind": 5,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "variance = n * p * (1 - p)\nWhere n is the number of experiments.\n# defense that will decrease the probability of infection and death\nDefine the rules of the simulation\nZombie infection - if a zombie and survivor are in neighbouring cell, the survivor will become infected\nSurvivor attack - if a zombie and survivor are in neighbouring cell, if a zombie dies, it is removed from the simulation\nZombie movement - each zombie moves one unit towards a random direction\nSurvivor movement - each survivor moves one unit away from the nearest zombie\na: individual: zombie and survivor, cell: position, grid: zombie_positions and survivor_positions, simulation: update_simulation()\nfunctional programming",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "car",
        "kind": 5,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "car = SportsCar()\ncar.drive() # \"Driving a sports car at high speed!\"\nThe problem with this approach is that any changes made to the 'drive' method in the 'Car' class will also affect the 'SportsCar' class, as they share the same implementation. Additionally, if we want to add another type of car, we will have to create another subclass and repeat the same process, making the code more complex and less maintainable.\nWthout using the Bridge pattern, we would likely have a single class that contains both the interface and the implementation, making the code tightly coupled and less maintainable. This would mean that any changes made to the implementation would directly affect any references or dependencies on the code.\n\"\"\"\n\"\"\"\n/* Implementor interface*/\ninterface Gear{\n    void handleGear();\n}",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "car1",
        "kind": 5,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "car1 = SportsCar(XSportsCarInterface())\ncar2 = SportsCar(YSportsCarInterface())\ncar3 = Truck(XTruckInterface())\ncar4 = Truck(YTruckInterface())\ncar1.drive() # \"Driving a sports car from manufacturer X at high speed!\"\ncar2.drive() # \"Driving a sports car from manufacturer Y at high speed!\"\ncar3.drive() # \"Driving a truck from manufacturer X at low speed.\"\ncar4.drive() # \"Driving a truck from manufacturer Y at low speed.\"\nThe Bridge pattern is a way to separate an abstraction from its implementation, allowing for the two to vary independently. Using the example of a car, we can see how the Bridge pattern can be applied.\nWe can start by creating a Car abstract class to represent the commonality between all cars. This abstract class would have methods and properties that all types of cars should have, such as a drive method. Then, we can create various subclasses for different types of cars, such as a SportsCar and a Truck class. This is a robust design, as it allows for many more types of cars to be added in the future.",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "car2",
        "kind": 5,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "car2 = SportsCar(YSportsCarInterface())\ncar3 = Truck(XTruckInterface())\ncar4 = Truck(YTruckInterface())\ncar1.drive() # \"Driving a sports car from manufacturer X at high speed!\"\ncar2.drive() # \"Driving a sports car from manufacturer Y at high speed!\"\ncar3.drive() # \"Driving a truck from manufacturer X at low speed.\"\ncar4.drive() # \"Driving a truck from manufacturer Y at low speed.\"\nThe Bridge pattern is a way to separate an abstraction from its implementation, allowing for the two to vary independently. Using the example of a car, we can see how the Bridge pattern can be applied.\nWe can start by creating a Car abstract class to represent the commonality between all cars. This abstract class would have methods and properties that all types of cars should have, such as a drive method. Then, we can create various subclasses for different types of cars, such as a SportsCar and a Truck class. This is a robust design, as it allows for many more types of cars to be added in the future.\nNow suppose that cars are provided by different manufacturers. We would have to create a hierarchy of car classes for manufacturer X and another for manufacturer Y. The problem now is that clients would need to know the difference between the manufacturers. And if we decide to support a third manufacturer, the codebase would become more complex.",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "car3",
        "kind": 5,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "car3 = Truck(XTruckInterface())\ncar4 = Truck(YTruckInterface())\ncar1.drive() # \"Driving a sports car from manufacturer X at high speed!\"\ncar2.drive() # \"Driving a sports car from manufacturer Y at high speed!\"\ncar3.drive() # \"Driving a truck from manufacturer X at low speed.\"\ncar4.drive() # \"Driving a truck from manufacturer Y at low speed.\"\nThe Bridge pattern is a way to separate an abstraction from its implementation, allowing for the two to vary independently. Using the example of a car, we can see how the Bridge pattern can be applied.\nWe can start by creating a Car abstract class to represent the commonality between all cars. This abstract class would have methods and properties that all types of cars should have, such as a drive method. Then, we can create various subclasses for different types of cars, such as a SportsCar and a Truck class. This is a robust design, as it allows for many more types of cars to be added in the future.\nNow suppose that cars are provided by different manufacturers. We would have to create a hierarchy of car classes for manufacturer X and another for manufacturer Y. The problem now is that clients would need to know the difference between the manufacturers. And if we decide to support a third manufacturer, the codebase would become more complex.\nThe solution is to provide the main abstraction hierarchy, i.e. the Car abstract class and subclasses such as SportsCar and Truck, and then provide the interface (Bridge) that will exist between the abstraction and the implementation. So there will be a CarInterface, SportsCarInterface, and TruckInterface, which dictate the interface that each concrete car class must provide. The abstraction (Car class) does not know about the implementation, rather it knows about the interface. Finally, we can create a concrete implementation for each manufacturer. That is, XCar, XSportsCar, and XTruck, YCar, YSportsCar and YTruck.",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "car4",
        "kind": 5,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "car4 = Truck(YTruckInterface())\ncar1.drive() # \"Driving a sports car from manufacturer X at high speed!\"\ncar2.drive() # \"Driving a sports car from manufacturer Y at high speed!\"\ncar3.drive() # \"Driving a truck from manufacturer X at low speed.\"\ncar4.drive() # \"Driving a truck from manufacturer Y at low speed.\"\nThe Bridge pattern is a way to separate an abstraction from its implementation, allowing for the two to vary independently. Using the example of a car, we can see how the Bridge pattern can be applied.\nWe can start by creating a Car abstract class to represent the commonality between all cars. This abstract class would have methods and properties that all types of cars should have, such as a drive method. Then, we can create various subclasses for different types of cars, such as a SportsCar and a Truck class. This is a robust design, as it allows for many more types of cars to be added in the future.\nNow suppose that cars are provided by different manufacturers. We would have to create a hierarchy of car classes for manufacturer X and another for manufacturer Y. The problem now is that clients would need to know the difference between the manufacturers. And if we decide to support a third manufacturer, the codebase would become more complex.\nThe solution is to provide the main abstraction hierarchy, i.e. the Car abstract class and subclasses such as SportsCar and Truck, and then provide the interface (Bridge) that will exist between the abstraction and the implementation. So there will be a CarInterface, SportsCarInterface, and TruckInterface, which dictate the interface that each concrete car class must provide. The abstraction (Car class) does not know about the implementation, rather it knows about the interface. Finally, we can create a concrete implementation for each manufacturer. That is, XCar, XSportsCar, and XTruck, YCar, YSportsCar and YTruck.\nClients depend only on the abstraction but any implementation could be plugged in. So in this setup, the abstraction (Car class) could be changed without changing any of the concrete classes, and the implementation could be changed without worrying about the abstraction. This allows for a more flexible and maintainable codebase.",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "receiver",
        "kind": 5,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "receiver = Receiver()\ncommand = SimpleCommand(receiver, \"Action 1\")\ninvoker = Invoker()\ninvoker.store_command(command)\ninvoker.execute_commands()  # Output: Performing action: Action 1\ninvoker does not know anything about the receiver or the command.\nReceiver and command should be decoupled from each other.\nThis can be done by not delegating the command execution to the receiver.\nInstead, the command should be responsible for executing the action.\nThere are two ways to undo a command:",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "command",
        "kind": 5,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "command = SimpleCommand(receiver, \"Action 1\")\ninvoker = Invoker()\ninvoker.store_command(command)\ninvoker.execute_commands()  # Output: Performing action: Action 1\ninvoker does not know anything about the receiver or the command.\nReceiver and command should be decoupled from each other.\nThis can be done by not delegating the command execution to the receiver.\nInstead, the command should be responsible for executing the action.\nThere are two ways to undo a command:\n1. Store the state of the receiver before executing the command in the command itself, combining the momento pattern",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "invoker",
        "kind": 5,
        "importPath": "population",
        "description": "population",
        "peekOfCode": "invoker = Invoker()\ninvoker.store_command(command)\ninvoker.execute_commands()  # Output: Performing action: Action 1\ninvoker does not know anything about the receiver or the command.\nReceiver and command should be decoupled from each other.\nThis can be done by not delegating the command execution to the receiver.\nInstead, the command should be responsible for executing the action.\nThere are two ways to undo a command:\n1. Store the state of the receiver before executing the command in the command itself, combining the momento pattern\n2. Call an unexecute method of the receiver",
        "detail": "population",
        "documentation": {}
    },
    {
        "label": "model_population_size",
        "kind": 2,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "def model_population_size(P0, L, t0, t_final):\n    \"\"\"\n    Model the population size during a zombie apocalypse using a matrix algebra model and a differential equation.\n    \"\"\"\n    # Define the differential equation\n    def dP_dt(t, P, L):\n        return L @ P\n    # Generate a numerical solution of the differential equation\n    solution = solve_ivp(dP_dt, [t0, t_final], P0, args=(L,))\n    # Extract the population size at each time point",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "dP_dt",
        "kind": 2,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "def dP_dt(P, t, growth_rate, carrying_capacity, death_rate, emigration_rate):\n    \"\"\"\n    A differential equation called logistic growth that describes how the population size of a species can change over time.\n    \"\"\"\n    real_growth_rate = growth_rate * (1 - P/carrying_capacity)\n    real_death_rate = death_rate * P\n    real_emigration_rate = emigration_rate * P\n    return real_growth_rate - real_death_rate - real_emigration_rate\ndef find_equilibrium_points(growth_rate, carrying_capacity, death_rate, emigration_rate):\n    \"\"\"",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "find_equilibrium_points",
        "kind": 2,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "def find_equilibrium_points(growth_rate, carrying_capacity, death_rate, emigration_rate):\n    \"\"\"\n    Find the equilibrium points of the differential equation, and identify stable and unstable equilibrium points and oscillations.\n    \"\"\"\n    equilibrium_points = fsolve(dP_dt, [-1000, -100, -10, -1, 0, 1, 10, 100, 1000], args=(\n        growth_rate, carrying_capacity, death_rate, emigration_rate))\n    equilibrium_points = [point for point in equilibrium_points if np.isclose(\n        dP_dt(point, 0, growth_rate, carrying_capacity, death_rate, emigration_rate), 0)]\n    return equilibrium_points\ndef analyze_stability(P, growth_rate, carrying_capacity, death_rate, emigration_rate):",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "analyze_stability",
        "kind": 2,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "def analyze_stability(P, growth_rate, carrying_capacity, death_rate, emigration_rate):\n    \"\"\"\n    Analyze the stability and convergence by representing the differential equation as a matrix equation and use matrix algebra to find eigenvalues and eigenvectors and analyze the behavior of the system over time.\n    \"\"\"\n    A = np.array(\n        [[-death_rate, -emigration_rate, growth_rate * (1 - P/carrying_capacity)]])\n    eigenvalues, eigenvectors = np.linalg.eig(A)\n    return eigenvalues, eigenvectors\ndef perform_sensitivity_analysis(t0, t_final, P0, growth_rate, carrying_capacity, death_rate, emigration_rate, parameter_values):\n    \"\"\"",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "perform_sensitivity_analysis",
        "kind": 2,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "def perform_sensitivity_analysis(t0, t_final, P0, growth_rate, carrying_capacity, death_rate, emigration_rate, parameter_values):\n    \"\"\"\n    Perform a sensitivity analysis of the differential equation to identify the sensitivity of the system to changes in the assumptions or parameters.\n    \"\"\"\n    sensitivity_results = []\n    for growth_rate_list in parameter_values:\n        sensitivity_solution = solve_ivp(dP_dt, [t0, t_final], [P0], args=(\n            growth_rate_list, carrying_capacity, death_rate, emigration_rate))\n        sensitivity_results.append(sensitivity_solution.y[0])\n    return sensitivity_results",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "generate_numerical_solution",
        "kind": 2,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "def generate_numerical_solution(t0, t_final, P0, growth_rate, carrying_capacity, death_rate, emigration_rate):\n    \"\"\"\n    Generate a numerical solution of the differential equation.\n    \"\"\"\n    solution = solve_ivp(dP_dt, [t0, t_final], [P0], args=(\n        growth_rate, carrying_capacity, death_rate, emigration_rate))\n    return solution.t, solution.y[0]\n# event in solve_ivp happen when number of either is 0\n# a = solve_ivp(dP_dt, [t0, t_final], [P0], args=(growth_rate, carrying_capacity, death_rate, emigration_rate), events=(lambda t, y: y[0] - 0, lambda t, y: y[1] - 0))\ndef run_monte_carlo_simulation(t0, t_final, growth_rate, carrying_capacity, death_rate, emigration_rate, num_simulations, growth_rate_bounds, carrying_capacity_bounds, death_rate_bounds, emigration_rate_bounds, P0_bounds):",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "run_monte_carlo_simulation",
        "kind": 2,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "def run_monte_carlo_simulation(t0, t_final, growth_rate, carrying_capacity, death_rate, emigration_rate, num_simulations, growth_rate_bounds, carrying_capacity_bounds, death_rate_bounds, emigration_rate_bounds, P0_bounds):\n  \"\"\"\n  Run a Monte Carlo simulation of the population size.\n  \"\"\"\n  # Initialize lists to store the results of the simulations\n  t_values = []\n  P_values = []\n  # Run the Monte Carlo simulation\n  for i in range(num_simulations):\n    # Generate random samples of the parameters and initial conditions",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "P0",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "P0 = np.array([10000, 1000, 1000])\n# Transition matrix\nL = np.array([[0.9, 0.05, 0.05], [0.1, 0.8, 0.1], [0.2, 0.2, 0.6]])\n# Initial time\nt0 = 0\n# Set the time period for the simulation (in days)\nt_final = 365\n# Model the population size\nt, P = model_population_size(P0, L, t0, t_final)\nprint(P)",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "L",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "L = np.array([[0.9, 0.05, 0.05], [0.1, 0.8, 0.1], [0.2, 0.2, 0.6]])\n# Initial time\nt0 = 0\n# Set the time period for the simulation (in days)\nt_final = 365\n# Model the population size\nt, P = model_population_size(P0, L, t0, t_final)\nprint(P)\n\"\"\"\nThis code defines an initial population size as a NumPy array of three values [10000, 1000, 1000], which represents the number of humans, zombies, and dead bodies in the population. It also defines a transition matrix as a 3x3 NumPy array [[0.9, 0.05, 0.05], [0.1, 0.8, 0.1], [0.2, 0.2, 0.6]], which represents the probability of transitions between the different states (human, zombie, or dead).",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "t0",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "t0 = 0\n# Set the time period for the simulation (in days)\nt_final = 365\n# Model the population size\nt, P = model_population_size(P0, L, t0, t_final)\nprint(P)\n\"\"\"\nThis code defines an initial population size as a NumPy array of three values [10000, 1000, 1000], which represents the number of humans, zombies, and dead bodies in the population. It also defines a transition matrix as a 3x3 NumPy array [[0.9, 0.05, 0.05], [0.1, 0.8, 0.1], [0.2, 0.2, 0.6]], which represents the probability of transitions between the different states (human, zombie, or dead).\nThe code then uses a loop to compute the population size at each time point by iteratively multiplying the initial population size by the transition matrix. At the end of the simulation, the final population size will be printed to the console.\nThis matrix algebra model is a simplified representation of the population size during a zombie apocalypse, but it can still provide insight into the behavior of the population over time. For example, you could use this model to understand how the number of humans, zombies, and dead bodies in the population changes over time, and to identify any trends or patterns in the data.",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "t_final",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "t_final = 365\n# Model the population size\nt, P = model_population_size(P0, L, t0, t_final)\nprint(P)\n\"\"\"\nThis code defines an initial population size as a NumPy array of three values [10000, 1000, 1000], which represents the number of humans, zombies, and dead bodies in the population. It also defines a transition matrix as a 3x3 NumPy array [[0.9, 0.05, 0.05], [0.1, 0.8, 0.1], [0.2, 0.2, 0.6]], which represents the probability of transitions between the different states (human, zombie, or dead).\nThe code then uses a loop to compute the population size at each time point by iteratively multiplying the initial population size by the transition matrix. At the end of the simulation, the final population size will be printed to the console.\nThis matrix algebra model is a simplified representation of the population size during a zombie apocalypse, but it can still provide insight into the behavior of the population over time. For example, you could use this model to understand how the number of humans, zombies, and dead bodies in the population changes over time, and to identify any trends or patterns in the data.\n\"\"\"\n\"\"\"",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "P0",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "P0 = 100\nt0 = 0\nt_final = 100\n# Define the parameters for the differential equation\ngrowth_rate = 0.1\ncarrying_capacity = 1000\ndeath_rate = 0.05\nemigration_rate = 0.01\n# Define the parameter values to use in the sensitivity analysis\nparameter_values = [0.1, 0.5, 1, 2, 5]",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "t0",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "t0 = 0\nt_final = 100\n# Define the parameters for the differential equation\ngrowth_rate = 0.1\ncarrying_capacity = 1000\ndeath_rate = 0.05\nemigration_rate = 0.01\n# Define the parameter values to use in the sensitivity analysis\nparameter_values = [0.1, 0.5, 1, 2, 5]\n# Set the number of simulations to run",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "t_final",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "t_final = 100\n# Define the parameters for the differential equation\ngrowth_rate = 0.1\ncarrying_capacity = 1000\ndeath_rate = 0.05\nemigration_rate = 0.01\n# Define the parameter values to use in the sensitivity analysis\nparameter_values = [0.1, 0.5, 1, 2, 5]\n# Set the number of simulations to run\nnum_simulations = 1000",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "growth_rate",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "growth_rate = 0.1\ncarrying_capacity = 1000\ndeath_rate = 0.05\nemigration_rate = 0.01\n# Define the parameter values to use in the sensitivity analysis\nparameter_values = [0.1, 0.5, 1, 2, 5]\n# Set the number of simulations to run\nnum_simulations = 1000\n# Set the bounds for the random samples\ngrowth_rate_bounds = (0.01, 0.5)",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "carrying_capacity",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "carrying_capacity = 1000\ndeath_rate = 0.05\nemigration_rate = 0.01\n# Define the parameter values to use in the sensitivity analysis\nparameter_values = [0.1, 0.5, 1, 2, 5]\n# Set the number of simulations to run\nnum_simulations = 1000\n# Set the bounds for the random samples\ngrowth_rate_bounds = (0.01, 0.5)\ncarrying_capacity_bounds = (500, 1500)",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "death_rate",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "death_rate = 0.05\nemigration_rate = 0.01\n# Define the parameter values to use in the sensitivity analysis\nparameter_values = [0.1, 0.5, 1, 2, 5]\n# Set the number of simulations to run\nnum_simulations = 1000\n# Set the bounds for the random samples\ngrowth_rate_bounds = (0.01, 0.5)\ncarrying_capacity_bounds = (500, 1500)\ndeath_rate_bounds = (0.01, 0.1)",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "emigration_rate",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "emigration_rate = 0.01\n# Define the parameter values to use in the sensitivity analysis\nparameter_values = [0.1, 0.5, 1, 2, 5]\n# Set the number of simulations to run\nnum_simulations = 1000\n# Set the bounds for the random samples\ngrowth_rate_bounds = (0.01, 0.5)\ncarrying_capacity_bounds = (500, 1500)\ndeath_rate_bounds = (0.01, 0.1)\nemigration_rate_bounds = (0.01, 0.1)",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "parameter_values",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "parameter_values = [0.1, 0.5, 1, 2, 5]\n# Set the number of simulations to run\nnum_simulations = 1000\n# Set the bounds for the random samples\ngrowth_rate_bounds = (0.01, 0.5)\ncarrying_capacity_bounds = (500, 1500)\ndeath_rate_bounds = (0.01, 0.1)\nemigration_rate_bounds = (0.01, 0.1)\nP0_bounds = (50, 150)\n# Find the equilibrium points",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "num_simulations",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "num_simulations = 1000\n# Set the bounds for the random samples\ngrowth_rate_bounds = (0.01, 0.5)\ncarrying_capacity_bounds = (500, 1500)\ndeath_rate_bounds = (0.01, 0.1)\nemigration_rate_bounds = (0.01, 0.1)\nP0_bounds = (50, 150)\n# Find the equilibrium points\nequilibrium_points = find_equilibrium_points(\n    growth_rate, carrying_capacity, death_rate, emigration_rate)",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "growth_rate_bounds",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "growth_rate_bounds = (0.01, 0.5)\ncarrying_capacity_bounds = (500, 1500)\ndeath_rate_bounds = (0.01, 0.1)\nemigration_rate_bounds = (0.01, 0.1)\nP0_bounds = (50, 150)\n# Find the equilibrium points\nequilibrium_points = find_equilibrium_points(\n    growth_rate, carrying_capacity, death_rate, emigration_rate)\nprint(\"Equilibrium points:\", equilibrium_points)\n# Analyze the stability of the system",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "carrying_capacity_bounds",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "carrying_capacity_bounds = (500, 1500)\ndeath_rate_bounds = (0.01, 0.1)\nemigration_rate_bounds = (0.01, 0.1)\nP0_bounds = (50, 150)\n# Find the equilibrium points\nequilibrium_points = find_equilibrium_points(\n    growth_rate, carrying_capacity, death_rate, emigration_rate)\nprint(\"Equilibrium points:\", equilibrium_points)\n# Analyze the stability of the system\neigenvalues, eigenvectors = analyze_stability(",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "death_rate_bounds",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "death_rate_bounds = (0.01, 0.1)\nemigration_rate_bounds = (0.01, 0.1)\nP0_bounds = (50, 150)\n# Find the equilibrium points\nequilibrium_points = find_equilibrium_points(\n    growth_rate, carrying_capacity, death_rate, emigration_rate)\nprint(\"Equilibrium points:\", equilibrium_points)\n# Analyze the stability of the system\neigenvalues, eigenvectors = analyze_stability(\n    P0, growth_rate, carrying_capacity, death_rate, emigration_rate)",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "emigration_rate_bounds",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "emigration_rate_bounds = (0.01, 0.1)\nP0_bounds = (50, 150)\n# Find the equilibrium points\nequilibrium_points = find_equilibrium_points(\n    growth_rate, carrying_capacity, death_rate, emigration_rate)\nprint(\"Equilibrium points:\", equilibrium_points)\n# Analyze the stability of the system\neigenvalues, eigenvectors = analyze_stability(\n    P0, growth_rate, carrying_capacity, death_rate, emigration_rate)\n# Analyze the eigenvalues and eigenvectors to gain insights into the behavior of the system",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "P0_bounds",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "P0_bounds = (50, 150)\n# Find the equilibrium points\nequilibrium_points = find_equilibrium_points(\n    growth_rate, carrying_capacity, death_rate, emigration_rate)\nprint(\"Equilibrium points:\", equilibrium_points)\n# Analyze the stability of the system\neigenvalues, eigenvectors = analyze_stability(\n    P0, growth_rate, carrying_capacity, death_rate, emigration_rate)\n# Analyze the eigenvalues and eigenvectors to gain insights into the behavior of the system\nfor i, (eigenvalue, eigenvector) in enumerate(zip(eigenvalues, eigenvectors)):",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "equilibrium_points",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "equilibrium_points = find_equilibrium_points(\n    growth_rate, carrying_capacity, death_rate, emigration_rate)\nprint(\"Equilibrium points:\", equilibrium_points)\n# Analyze the stability of the system\neigenvalues, eigenvectors = analyze_stability(\n    P0, growth_rate, carrying_capacity, death_rate, emigration_rate)\n# Analyze the eigenvalues and eigenvectors to gain insights into the behavior of the system\nfor i, (eigenvalue, eigenvector) in enumerate(zip(eigenvalues, eigenvectors)):\n    print(f\"Eigenvalue {i}: {eigenvalue}\")\n    print(f\"Eigenvector {i}: {eigenvector}\")",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "P_init",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "P_init = eigenvectors[:, np.argmax(eigenvalues)]\n# Generate a numerical solution of the equation\nt, P = generate_numerical_solution(t0, t_final, P_init, growth_rate, carrying_capacity, death_rate, emigration_rate)\n\"\"\"\n# Perform a sensitivity analysis\nsensitivity_results = perform_sensitivity_analysis(\n    t0, t_final, P0, growth_rate, carrying_capacity, death_rate, emigration_rate, parameter_values)\nprint(\"Sensitivity results:\", sensitivity_results)\n# Plot the sensitivity analysis results\nfor i, sensitivity_result in enumerate(sensitivity_results):",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "sensitivity_results",
        "kind": 5,
        "importPath": "population1",
        "description": "population1",
        "peekOfCode": "sensitivity_results = perform_sensitivity_analysis(\n    t0, t_final, P0, growth_rate, carrying_capacity, death_rate, emigration_rate, parameter_values)\nprint(\"Sensitivity results:\", sensitivity_results)\n# Plot the sensitivity analysis results\nfor i, sensitivity_result in enumerate(sensitivity_results):\n    plt.plot(t, sensitivity_result, label=f\"growth rate = {parameter_values[i]}\")\nplt.xlabel(\"Time\")\nplt.ylabel(\"Population size\")\nplt.legend()\nplt.show()",
        "detail": "population1",
        "documentation": {}
    },
    {
        "label": "Direction",
        "kind": 6,
        "importPath": "protocol",
        "description": "protocol",
        "peekOfCode": "class Direction(Enum):\n    N = 'n'\n    E = 'e'\n    S = 's'\n    W = 'w'\n    NE = 'ne'\n    SE = 'se'\n    SW = 'sw'\n    NW = 'nw'\n@dataclass",
        "detail": "protocol",
        "documentation": {}
    },
    {
        "label": "Movement",
        "kind": 6,
        "importPath": "protocol",
        "description": "protocol",
        "peekOfCode": "class Movement:\n    \"\"\"A movement by an object in a direction.\"\"\"\n    obj: Any\n    distance_meters: int\n    direction: Direction\nclass Waiter(Protocol):\n    def wait(self, actions_spent: int, direction: Direction) -> Movement:\n        \"\"\"A Waiter can wait\"\"\"\nclass Flyer(Protocol):\n    def fly(self, actions_spent: int, direction: Direction) -> Movement:",
        "detail": "protocol",
        "documentation": {}
    },
    {
        "label": "Waiter",
        "kind": 6,
        "importPath": "protocol",
        "description": "protocol",
        "peekOfCode": "class Waiter(Protocol):\n    def wait(self, actions_spent: int, direction: Direction) -> Movement:\n        \"\"\"A Waiter can wait\"\"\"\nclass Flyer(Protocol):\n    def fly(self, actions_spent: int, direction: Direction) -> Movement:\n        \"\"\"A Flyer can fly\"\"\"\nclass Runner(Protocol):\n    def run(self, actions_spent: int, direction: Direction) -> Movement:\n        \"\"\"A Runner can run\"\"\"\nclass BaseHero:",
        "detail": "protocol",
        "documentation": {}
    },
    {
        "label": "Flyer",
        "kind": 6,
        "importPath": "protocol",
        "description": "protocol",
        "peekOfCode": "class Flyer(Protocol):\n    def fly(self, actions_spent: int, direction: Direction) -> Movement:\n        \"\"\"A Flyer can fly\"\"\"\nclass Runner(Protocol):\n    def run(self, actions_spent: int, direction: Direction) -> Movement:\n        \"\"\"A Runner can run\"\"\"\nclass BaseHero:\n    @property\n    def max_speed(self) -> int:\n        return 1",
        "detail": "protocol",
        "documentation": {}
    },
    {
        "label": "Runner",
        "kind": 6,
        "importPath": "protocol",
        "description": "protocol",
        "peekOfCode": "class Runner(Protocol):\n    def run(self, actions_spent: int, direction: Direction) -> Movement:\n        \"\"\"A Runner can run\"\"\"\nclass BaseHero:\n    @property\n    def max_speed(self) -> int:\n        return 1\n    def wait(self, actions_spent: int, direction: Direction) -> Movement:\n        return Movement(obj=self, distance_meters=0, direction=direction)\nclass RunningHero(BaseHero):",
        "detail": "protocol",
        "documentation": {}
    },
    {
        "label": "BaseHero",
        "kind": 6,
        "importPath": "protocol",
        "description": "protocol",
        "peekOfCode": "class BaseHero:\n    @property\n    def max_speed(self) -> int:\n        return 1\n    def wait(self, actions_spent: int, direction: Direction) -> Movement:\n        return Movement(obj=self, distance_meters=0, direction=direction)\nclass RunningHero(BaseHero):\n    \"\"\"This hero can run, which is better than nothing.\"\"\"\n    @property\n    def run_speed(self) -> int:",
        "detail": "protocol",
        "documentation": {}
    },
    {
        "label": "RunningHero",
        "kind": 6,
        "importPath": "protocol",
        "description": "protocol",
        "peekOfCode": "class RunningHero(BaseHero):\n    \"\"\"This hero can run, which is better than nothing.\"\"\"\n    @property\n    def run_speed(self) -> int:\n        return self.max_speed * 2\n    def run(self, actions_spent: int, direction: Direction) -> Movement:\n        return Movement(obj=self,\n                        distance_meters=self.run_speed * actions_spent,\n                        direction=direction)\nclass FlyingHero(BaseHero):",
        "detail": "protocol",
        "documentation": {}
    },
    {
        "label": "FlyingHero",
        "kind": 6,
        "importPath": "protocol",
        "description": "protocol",
        "peekOfCode": "class FlyingHero(BaseHero):\n    \"\"\"This hero can fly, which is BEAST.\"\"\"\n    @property\n    def fly_speed(self) -> int:\n        return self.max_speed * 5\n    def fly(self, actions_spent: int, direction: Direction) -> Movement:\n        return Movement(obj=self,\n                        distance_meters=self.fly_speed * actions_spent,\n                        direction=direction)\nclass Board:",
        "detail": "protocol",
        "documentation": {}
    },
    {
        "label": "Board",
        "kind": 6,
        "importPath": "protocol",
        "description": "protocol",
        "peekOfCode": "class Board:\n    \"\"\"An imaginary game board that doesn't do anything.\"\"\"\n    def make_wait(self, obj: Waiter, direction: Direction,\n                  actions_spent: int) -> Movement:\n        \"\"\"Make an object wait.\n        ``obj`` is the object to make wait\n        ``actions`` is the number of consecutive actions taken to wait\n        Returns the total distance in meters that ``piece`` moved on the board\n        while waiting (could happen...).\n        \"\"\"",
        "detail": "protocol",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "protocol",
        "description": "protocol",
        "peekOfCode": "def main() -> None:\n    board = Board()\n    waiter_move = board.make_wait(BaseHero(), Direction.N, 2)\n    runner_move = board.make_run(RunningHero(), Direction.NW, 2)\n    flyer_move = board.make_fly(FlyingHero(), Direction.S, 2)\n    heroes = (('Hero', 'Total spaces moved (M)'),\n              ('a waiting hero', waiter_move.distance_meters),\n              ('a running hero', runner_move.distance_meters),\n              ('a flying hero', flyer_move.distance_meters))\n    print('\\n')",
        "detail": "protocol",
        "documentation": {}
    },
    {
        "label": "mse",
        "kind": 2,
        "importPath": "regression",
        "description": "regression",
        "peekOfCode": "def mse(y, y_pred):\n    return ((y - y_pred) ** 2).mean()\n# Define the gradient descent update rule\ndef update_params(w, b, X, y, y_pred, alpha):\n    w_grad = -2 * X.T.dot(y - y_pred) / len(y)\n    b_grad = -2 * (y - y_pred).mean()\n    w -= alpha * w_grad\n    b -= alpha * b_grad\n    return w, b\n# Define the prediction function",
        "detail": "regression",
        "documentation": {}
    },
    {
        "label": "update_params",
        "kind": 2,
        "importPath": "regression",
        "description": "regression",
        "peekOfCode": "def update_params(w, b, X, y, y_pred, alpha):\n    w_grad = -2 * X.T.dot(y - y_pred) / len(y)\n    b_grad = -2 * (y - y_pred).mean()\n    w -= alpha * w_grad\n    b -= alpha * b_grad\n    return w, b\n# Define the prediction function\ndef predict(w, b, X):\n    return X.dot(w) + b\n# Fit the model to the data",
        "detail": "regression",
        "documentation": {}
    },
    {
        "label": "predict",
        "kind": 2,
        "importPath": "regression",
        "description": "regression",
        "peekOfCode": "def predict(w, b, X):\n    return X.dot(w) + b\n# Fit the model to the data\nfor i in range(10000):\n    y_pred = predict(w, b, X)\n    w, b = update_params(w, b, X, y, y_pred, alpha)\n    if i % 10 == 0:\n        print(f\"Iteration {i}: MSE = {mse(y, y_pred)}\")\n# Use the model to make predictions on new data\nX_new = np.array([[6, 7, 8]])",
        "detail": "regression",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "regression",
        "description": "regression",
        "peekOfCode": "X = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]])\ny = np.array([1, 2, 3, 4, 5])\n# Initialize the model parameters\nw = np.zeros(3)\nb = 0\n# Set the learning rate\nalpha = 0.0001\n# Define the mean squared error loss function\ndef mse(y, y_pred):\n    return ((y - y_pred) ** 2).mean()",
        "detail": "regression",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "regression",
        "description": "regression",
        "peekOfCode": "y = np.array([1, 2, 3, 4, 5])\n# Initialize the model parameters\nw = np.zeros(3)\nb = 0\n# Set the learning rate\nalpha = 0.0001\n# Define the mean squared error loss function\ndef mse(y, y_pred):\n    return ((y - y_pred) ** 2).mean()\n# Define the gradient descent update rule",
        "detail": "regression",
        "documentation": {}
    },
    {
        "label": "w",
        "kind": 5,
        "importPath": "regression",
        "description": "regression",
        "peekOfCode": "w = np.zeros(3)\nb = 0\n# Set the learning rate\nalpha = 0.0001\n# Define the mean squared error loss function\ndef mse(y, y_pred):\n    return ((y - y_pred) ** 2).mean()\n# Define the gradient descent update rule\ndef update_params(w, b, X, y, y_pred, alpha):\n    w_grad = -2 * X.T.dot(y - y_pred) / len(y)",
        "detail": "regression",
        "documentation": {}
    },
    {
        "label": "b",
        "kind": 5,
        "importPath": "regression",
        "description": "regression",
        "peekOfCode": "b = 0\n# Set the learning rate\nalpha = 0.0001\n# Define the mean squared error loss function\ndef mse(y, y_pred):\n    return ((y - y_pred) ** 2).mean()\n# Define the gradient descent update rule\ndef update_params(w, b, X, y, y_pred, alpha):\n    w_grad = -2 * X.T.dot(y - y_pred) / len(y)\n    b_grad = -2 * (y - y_pred).mean()",
        "detail": "regression",
        "documentation": {}
    },
    {
        "label": "alpha",
        "kind": 5,
        "importPath": "regression",
        "description": "regression",
        "peekOfCode": "alpha = 0.0001\n# Define the mean squared error loss function\ndef mse(y, y_pred):\n    return ((y - y_pred) ** 2).mean()\n# Define the gradient descent update rule\ndef update_params(w, b, X, y, y_pred, alpha):\n    w_grad = -2 * X.T.dot(y - y_pred) / len(y)\n    b_grad = -2 * (y - y_pred).mean()\n    w -= alpha * w_grad\n    b -= alpha * b_grad",
        "detail": "regression",
        "documentation": {}
    },
    {
        "label": "X_new",
        "kind": 5,
        "importPath": "regression",
        "description": "regression",
        "peekOfCode": "X_new = np.array([[6, 7, 8]])\ny_new_pred = predict(w, b, X_new)\nprint(f\"Prediction for population size at time 6: {y_new_pred}\")",
        "detail": "regression",
        "documentation": {}
    },
    {
        "label": "y_new_pred",
        "kind": 5,
        "importPath": "regression",
        "description": "regression",
        "peekOfCode": "y_new_pred = predict(w, b, X_new)\nprint(f\"Prediction for population size at time 6: {y_new_pred}\")",
        "detail": "regression",
        "documentation": {}
    },
    {
        "label": "Student",
        "kind": 6,
        "importPath": "school",
        "description": "school",
        "peekOfCode": "class Student:\n    def __init__(self, name, group=None, pressure=0):\n        self.name = name\n        self.group = group\n        self.pressure = pressure\n        self.friends = []\n    def add_friend(self, student):\n        if student not in self.friends:\n            self.friends.append(student)\n            student.friends.append(self)",
        "detail": "school",
        "documentation": {}
    },
    {
        "label": "School",
        "kind": 6,
        "importPath": "school",
        "description": "school",
        "peekOfCode": "class School:\n    def __init__(self, students, teachers, social_groups, hierarchy, peer_pressure, social_norms):\n        self.teachers = teachers\n        self.students = {student.name: student for student in students}\n        self.social_groups = social_groups\n        self.hierarchy = hierarchy\n        self.peer_pressure = peer_pressure\n        self.social_norms = social_norms\n    def add_student(self, student: Student):\n        \"\"\"Adds a student to the school\"\"\"",
        "detail": "school",
        "documentation": {}
    },
    {
        "label": "Student",
        "kind": 6,
        "importPath": "school",
        "description": "school",
        "peekOfCode": "class Student:\n    def __init__(self, name, combat_skills, physical_health, weapons):\n        self.name = name\n        self.combat_skills = combat_skills\n        self.physical_health = physical_health\n        self.weapons = weapons\n    def engage_in_combat(self, zombie):\n        \"\"\"Engages in combat with the given number of zombies\"\"\"\n        # combat logic\n        pass",
        "detail": "school",
        "documentation": {}
    },
    {
        "label": "School",
        "kind": 6,
        "importPath": "school",
        "description": "school",
        "peekOfCode": "class School:\n    def __init__(self, students, leaders, social_groups, alliances, hierarchy, supplies, weapons):\n        self.students = students\n        self.leaders = leaders\n        self.social_groups = social_groups\n        self.alliances = alliances\n        self.hierarchy = hierarchy\n        self.supplies = supplies\n        self.weapons = weapons\n    def form_alliance(self, student1, student2):",
        "detail": "school",
        "documentation": {}
    },
    {
        "label": "School",
        "kind": 6,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "class School(object):\n    def __init__(self):\n        self.state = np.random.choice(states)\n        # define the matrix of states for each state and event\n        self.state_transitions = {\n            HIDING: {\n                NOISE: SEARCHING,\n                ZOMBIE: FIGHTING,\n                WEAPON: HIDING,\n            },",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "Person",
        "kind": 6,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "class Person(object):\n    def __init__(self):\n        self.state_machine = School()\n        self.action = np.random.choice(actions)\n        self.reward = 0\n        # define the matrix of actions for each state\n        self.Q = np.zeros((len(states), len(actions)))\n        self.update_q_values_globals = partial(self.update_q_values, LEARNING_RATE=0.001, DISCOUNT_RATE=0.999)\n        update_wrapper(self.update_q_values_globals, self.update_q_values)\n    def update(self):",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "Map",
        "kind": 6,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "class Map:\n    def __init__(self, size, supplies, weapons, survivors, zombies):\n        self.layout = None\n        self.supplies = supplies\n        self.weapons = weapons\n        self.survivors = survivors\n        self.zombies = zombies\n    def set_layout(self, layout):\n        self.layout = np.random.choice([\"Hallway\", \"Classroom\", \"Gym\", \"Cafeteria\", \"Library\", \"Auditorium\",\n                                       \"Office\", \"Bathroom\", \"Locker Room\", \"Playground\", \"Parking Lot\", \"Field\"], size=self.size)",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "simulation",
        "kind": 2,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "def simulation():\n    # define the number of people and the number of time steps\n    num_people = 1\n    num_steps = 1000\n    # create the people\n    people = [Person() for _ in range(num_people)]\n    for person in people:\n        # train the person\n        person.train(num_episodes=100, epsilon=0.25, survive=1, find_resources=5, kill_zombie=10, die_by_zombie=-100, learning_rate=0.001, discount_rate=0.999)\n    for step in range(num_steps):",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "select_action",
        "kind": 2,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "def select_action(person, event):\n    # Create a list of the current state and event\n    state_event = [person.state.is_hiding, person.state.is_fighting, person.state.is_running, event == \"Safe\", event == \"Overrun\", event == \"Noise\"]\n    # Create a list of the probabilities of selecting each action\n    probabilities = nn.predict(state_event)\n    # Select the next action based on the probabilities\n    action = np.random.choice(actions, p=probabilities)\n    # Return the next action\n    return action\n# training of the neural network using the simulation function",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "train_nn",
        "kind": 2,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "def train_nn(nn, steps, epochs):\n    # Iterate over the number of epochs\n    for _ in range(epochs):\n        # Generate a person\n        person = Person()\n        # Simulate the person's behavior\n        actions_taken = simulate(person, steps)\n        # Create a list of the current states and events\n        state_events = []\n        for i in range(len(actions_taken)):",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "HIDING",
        "kind": 5,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "HIDING = \"hiding\"\nSEARCHING = \"searching\"\nFIGHTING = \"fighting\"\nstates = [HIDING, SEARCHING, FIGHTING]\n# define the possible actions\n# determined by states and tactics\nHIDE = \"hide\"\nSEARCH = \"search\"\nFIGHT = \"fight\"\nactions = [HIDE, SEARCH, FIGHT]",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "SEARCHING",
        "kind": 5,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "SEARCHING = \"searching\"\nFIGHTING = \"fighting\"\nstates = [HIDING, SEARCHING, FIGHTING]\n# define the possible actions\n# determined by states and tactics\nHIDE = \"hide\"\nSEARCH = \"search\"\nFIGHT = \"fight\"\nactions = [HIDE, SEARCH, FIGHT]\n# define the possible events",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "FIGHTING",
        "kind": 5,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "FIGHTING = \"fighting\"\nstates = [HIDING, SEARCHING, FIGHTING]\n# define the possible actions\n# determined by states and tactics\nHIDE = \"hide\"\nSEARCH = \"search\"\nFIGHT = \"fight\"\nactions = [HIDE, SEARCH, FIGHT]\n# define the possible events\n# determined by states, actions, and possibilities",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "states",
        "kind": 5,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "states = [HIDING, SEARCHING, FIGHTING]\n# define the possible actions\n# determined by states and tactics\nHIDE = \"hide\"\nSEARCH = \"search\"\nFIGHT = \"fight\"\nactions = [HIDE, SEARCH, FIGHT]\n# define the possible events\n# determined by states, actions, and possibilities\nNOISE = \"noise\"",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "HIDE",
        "kind": 5,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "HIDE = \"hide\"\nSEARCH = \"search\"\nFIGHT = \"fight\"\nactions = [HIDE, SEARCH, FIGHT]\n# define the possible events\n# determined by states, actions, and possibilities\nNOISE = \"noise\"\nZOMBIE = \"zombie\"\nWEAPON = \"weapon\"\nevents = [NOISE, ZOMBIE, WEAPON]",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "SEARCH",
        "kind": 5,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "SEARCH = \"search\"\nFIGHT = \"fight\"\nactions = [HIDE, SEARCH, FIGHT]\n# define the possible events\n# determined by states, actions, and possibilities\nNOISE = \"noise\"\nZOMBIE = \"zombie\"\nWEAPON = \"weapon\"\nevents = [NOISE, ZOMBIE, WEAPON]\n# define the school class to store states and produce events",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "FIGHT",
        "kind": 5,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "FIGHT = \"fight\"\nactions = [HIDE, SEARCH, FIGHT]\n# define the possible events\n# determined by states, actions, and possibilities\nNOISE = \"noise\"\nZOMBIE = \"zombie\"\nWEAPON = \"weapon\"\nevents = [NOISE, ZOMBIE, WEAPON]\n# define the school class to store states and produce events\nclass School(object):",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "actions",
        "kind": 5,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "actions = [HIDE, SEARCH, FIGHT]\n# define the possible events\n# determined by states, actions, and possibilities\nNOISE = \"noise\"\nZOMBIE = \"zombie\"\nWEAPON = \"weapon\"\nevents = [NOISE, ZOMBIE, WEAPON]\n# define the school class to store states and produce events\nclass School(object):\n    def __init__(self):",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "NOISE",
        "kind": 5,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "NOISE = \"noise\"\nZOMBIE = \"zombie\"\nWEAPON = \"weapon\"\nevents = [NOISE, ZOMBIE, WEAPON]\n# define the school class to store states and produce events\nclass School(object):\n    def __init__(self):\n        self.state = np.random.choice(states)\n        # define the matrix of states for each state and event\n        self.state_transitions = {",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "ZOMBIE",
        "kind": 5,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "ZOMBIE = \"zombie\"\nWEAPON = \"weapon\"\nevents = [NOISE, ZOMBIE, WEAPON]\n# define the school class to store states and produce events\nclass School(object):\n    def __init__(self):\n        self.state = np.random.choice(states)\n        # define the matrix of states for each state and event\n        self.state_transitions = {\n            HIDING: {",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "WEAPON",
        "kind": 5,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "WEAPON = \"weapon\"\nevents = [NOISE, ZOMBIE, WEAPON]\n# define the school class to store states and produce events\nclass School(object):\n    def __init__(self):\n        self.state = np.random.choice(states)\n        # define the matrix of states for each state and event\n        self.state_transitions = {\n            HIDING: {\n                NOISE: SEARCHING,",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "events",
        "kind": 5,
        "importPath": "state_machine",
        "description": "state_machine",
        "peekOfCode": "events = [NOISE, ZOMBIE, WEAPON]\n# define the school class to store states and produce events\nclass School(object):\n    def __init__(self):\n        self.state = np.random.choice(states)\n        # define the matrix of states for each state and event\n        self.state_transitions = {\n            HIDING: {\n                NOISE: SEARCHING,\n                ZOMBIE: FIGHTING,",
        "detail": "state_machine",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "X = np.array([[1, 2, 3], [2, 3, 4], [3, 4, 5], [4, 5, 6], [5, 6, 7]])\ny = np.array([1, 2, 3, 4, 5])\n# Split the data into training and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.001)\n# Normalize the data\nX_mean = X_train.mean(axis=0)\nX_std = X_train.std(axis=0)\nX_train = (X_train - X_mean) / X_std\nX_test = (X_test - X_mean) / X_std\ny_mean = y_train.mean(axis=0)",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "y = np.array([1, 2, 3, 4, 5])\n# Split the data into training and test sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.001)\n# Normalize the data\nX_mean = X_train.mean(axis=0)\nX_std = X_train.std(axis=0)\nX_train = (X_train - X_mean) / X_std\nX_test = (X_test - X_mean) / X_std\ny_mean = y_train.mean(axis=0)\ny_std = y_train.std(axis=0)",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "X_mean",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "X_mean = X_train.mean(axis=0)\nX_std = X_train.std(axis=0)\nX_train = (X_train - X_mean) / X_std\nX_test = (X_test - X_mean) / X_std\ny_mean = y_train.mean(axis=0)\ny_std = y_train.std(axis=0)\ny_train = (y_train - y_mean) / y_std\ny_test = (y_test - y_mean) / y_std\n# Define the model\nmodel = tf.keras.Sequential([",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "X_std",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "X_std = X_train.std(axis=0)\nX_train = (X_train - X_mean) / X_std\nX_test = (X_test - X_mean) / X_std\ny_mean = y_train.mean(axis=0)\ny_std = y_train.std(axis=0)\ny_train = (y_train - y_mean) / y_std\ny_test = (y_test - y_mean) / y_std\n# Define the model\nmodel = tf.keras.Sequential([\n    tf.keras.layers.Dense(3, input_shape=(3,), activation='relu'),",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "X_train",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "X_train = (X_train - X_mean) / X_std\nX_test = (X_test - X_mean) / X_std\ny_mean = y_train.mean(axis=0)\ny_std = y_train.std(axis=0)\ny_train = (y_train - y_mean) / y_std\ny_test = (y_test - y_mean) / y_std\n# Define the model\nmodel = tf.keras.Sequential([\n    tf.keras.layers.Dense(3, input_shape=(3,), activation='relu'),\n    tf.keras.layers.BatchNormalization(),",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "X_test",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "X_test = (X_test - X_mean) / X_std\ny_mean = y_train.mean(axis=0)\ny_std = y_train.std(axis=0)\ny_train = (y_train - y_mean) / y_std\ny_test = (y_test - y_mean) / y_std\n# Define the model\nmodel = tf.keras.Sequential([\n    tf.keras.layers.Dense(3, input_shape=(3,), activation='relu'),\n    tf.keras.layers.BatchNormalization(),\n    tf.keras.layers.Dropout(0.1),",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "y_mean",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "y_mean = y_train.mean(axis=0)\ny_std = y_train.std(axis=0)\ny_train = (y_train - y_mean) / y_std\ny_test = (y_test - y_mean) / y_std\n# Define the model\nmodel = tf.keras.Sequential([\n    tf.keras.layers.Dense(3, input_shape=(3,), activation='relu'),\n    tf.keras.layers.BatchNormalization(),\n    tf.keras.layers.Dropout(0.1),\n    tf.keras.layers.Dense(1, activation='relu')",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "y_std",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "y_std = y_train.std(axis=0)\ny_train = (y_train - y_mean) / y_std\ny_test = (y_test - y_mean) / y_std\n# Define the model\nmodel = tf.keras.Sequential([\n    tf.keras.layers.Dense(3, input_shape=(3,), activation='relu'),\n    tf.keras.layers.BatchNormalization(),\n    tf.keras.layers.Dropout(0.1),\n    tf.keras.layers.Dense(1, activation='relu')\n])",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "y_train",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "y_train = (y_train - y_mean) / y_std\ny_test = (y_test - y_mean) / y_std\n# Define the model\nmodel = tf.keras.Sequential([\n    tf.keras.layers.Dense(3, input_shape=(3,), activation='relu'),\n    tf.keras.layers.BatchNormalization(),\n    tf.keras.layers.Dropout(0.1),\n    tf.keras.layers.Dense(1, activation='relu')\n])\n# Compile the model",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "y_test",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "y_test = (y_test - y_mean) / y_std\n# Define the model\nmodel = tf.keras.Sequential([\n    tf.keras.layers.Dense(3, input_shape=(3,), activation='relu'),\n    tf.keras.layers.BatchNormalization(),\n    tf.keras.layers.Dropout(0.1),\n    tf.keras.layers.Dense(1, activation='relu')\n])\n# Compile the model\nmodel.compile(optimizer='adam', loss='mean_squared_error')",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "model = tf.keras.Sequential([\n    tf.keras.layers.Dense(3, input_shape=(3,), activation='relu'),\n    tf.keras.layers.BatchNormalization(),\n    tf.keras.layers.Dropout(0.1),\n    tf.keras.layers.Dense(1, activation='relu')\n])\n# Compile the model\nmodel.compile(optimizer='adam', loss='mean_squared_error')\nmodel.summary()\n# Fit the model to the training data",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "y_pred",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "y_pred = model.predict(X_test)\n# Evaluate the model's performance\nmse = tf.keras.losses.mean_squared_error(y_test, y_pred).numpy()\nprint(f\"MSE: {mse}\")\n# Assume we have new data with various input variables (X_new)\nX_new = np.array([[6, 7, 8]])\n# Normalize the new data using the mean and standard deviation from the training data\nX_new = (X_new - X_mean) / X_std\n# Use the model to make predictions on the new data\ny_new_pred = model.predict(X_new)",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "mse",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "mse = tf.keras.losses.mean_squared_error(y_test, y_pred).numpy()\nprint(f\"MSE: {mse}\")\n# Assume we have new data with various input variables (X_new)\nX_new = np.array([[6, 7, 8]])\n# Normalize the new data using the mean and standard deviation from the training data\nX_new = (X_new - X_mean) / X_std\n# Use the model to make predictions on the new data\ny_new_pred = model.predict(X_new)\ny_new_pred = y_new_pred * y_std + y_mean\nprint(f\"Prediction for population size at time 6: {y_new_pred}\")",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "X_new",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "X_new = np.array([[6, 7, 8]])\n# Normalize the new data using the mean and standard deviation from the training data\nX_new = (X_new - X_mean) / X_std\n# Use the model to make predictions on the new data\ny_new_pred = model.predict(X_new)\ny_new_pred = y_new_pred * y_std + y_mean\nprint(f\"Prediction for population size at time 6: {y_new_pred}\")",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "X_new",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "X_new = (X_new - X_mean) / X_std\n# Use the model to make predictions on the new data\ny_new_pred = model.predict(X_new)\ny_new_pred = y_new_pred * y_std + y_mean\nprint(f\"Prediction for population size at time 6: {y_new_pred}\")",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "y_new_pred",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "y_new_pred = model.predict(X_new)\ny_new_pred = y_new_pred * y_std + y_mean\nprint(f\"Prediction for population size at time 6: {y_new_pred}\")",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "y_new_pred",
        "kind": 5,
        "importPath": "tensorflow_model",
        "description": "tensorflow_model",
        "peekOfCode": "y_new_pred = y_new_pred * y_std + y_mean\nprint(f\"Prediction for population size at time 6: {y_new_pred}\")",
        "detail": "tensorflow_model",
        "documentation": {}
    },
    {
        "label": "State",
        "kind": 6,
        "importPath": "test1",
        "description": "test1",
        "peekOfCode": "class State(Enum):\n    HEALTHY = auto()\n    INFECTED = auto()\n    ZOMBIE = auto()\n    DEAD = auto()\n    @classmethod\n    def name_list(cls) -> list[str]:\n        return [enm.name for enm in State]\n    @classmethod\n    def value_list(cls) -> list[int]:",
        "detail": "test1",
        "documentation": {}
    },
    {
        "label": "Agent",
        "kind": 6,
        "importPath": "test1",
        "description": "test1",
        "peekOfCode": "class Agent:\n    __slots__ = \"id\", \"state\", \"location\", \"connections\", \\\n    \"infection_severity\", \"interact_range\", \"sight_range\", \"__dict__\"\n    def __init__(self, id: int, state: State, location: tuple[int, int]) -> None:\n        self.id: int = id\n        self.state: State = state\n        self.location: tuple[int, int] = location\n        self.connections: list[Agent] = []\n        self.infection_severity: float = 0.0\n        self.interact_range: int = 2",
        "detail": "test1",
        "documentation": {}
    },
    {
        "label": "test_performance_1",
        "kind": 2,
        "importPath": "test1",
        "description": "test1",
        "peekOfCode": "def test_performance_1():\n    connections = [Agent(i, State.ZOMBIE, (random.randint(0, 100), random.randint(0, 100))) for i in range(10000)]\n    # Test the first version of the code\n    start_time = time.time()\n    for i in range(10000):\n        connections[i].is_infected(0.9)\n    end_time = time.time()\n    print(f\"First version took {end_time - start_time} seconds\")\n    connections = [Agent(i, State.ZOMBIE, (random.randint(0, 100), random.randint(0, 100))) for i in range(10000)]\n    # Test the second version of the code",
        "detail": "test1",
        "documentation": {}
    },
    {
        "label": "test_performance_2",
        "kind": 2,
        "importPath": "test1",
        "description": "test1",
        "peekOfCode": "def test_performance_2():\n    population = Population(100, 1)\n    # add 1 individuals to the school\n    individual = population.create_individual(2, 100)\n    population.add_individual(individual)\n    # Test the first version of the code\n    start_time = time.time()\n    for i in range(1000000):\n        population.school.random_move(individual)\n    end_time = time.time()",
        "detail": "test1",
        "documentation": {}
    },
    {
        "label": "test_state",
        "kind": 2,
        "importPath": "test_population",
        "description": "test_population",
        "peekOfCode": "def test_state():\n    assert State.name_list() == [\"HEALTHY\", \"INFECTED\", \"ZOMBIE\", \"DEAD\"]\n    assert State.value_list() == [1, 2, 3, 4]\n# pytest for Individual\ndef test_individual():\n    individual = Individual(1, State.HEALTHY, (0, 0))\n    assert individual.id == 1\n    assert individual.state == State.HEALTHY\n    assert individual.location == (0, 0)\n    assert individual.connections == []",
        "detail": "test_population",
        "documentation": {}
    },
    {
        "label": "test_individual",
        "kind": 2,
        "importPath": "test_population",
        "description": "test_population",
        "peekOfCode": "def test_individual():\n    individual = Individual(1, State.HEALTHY, (0, 0))\n    assert individual.id == 1\n    assert individual.state == State.HEALTHY\n    assert individual.location == (0, 0)\n    assert individual.connections == []\n    assert individual.infection_severity == 0.0\n    assert individual.interact_range == 2\n    assert individual.sight_range == 5\n    assert individual.get_info() == \"Individual 1 is HEALTHY and is located at (0, 0), having connections with [], infection severity 0.0, interact range 2, and sight range 5.\"",
        "detail": "test_population",
        "documentation": {}
    },
    {
        "label": "test_individual_class",
        "kind": 2,
        "importPath": "test_population",
        "description": "test_population",
        "peekOfCode": "def test_individual_class():\n    indiv = Individual(1, State.HEALTHY, (0, 0))\n    assert indiv.id == 1\n    assert indiv.state == State.HEALTHY\n    assert indiv.location == (0, 0)\n    assert indiv.connections == []\n    assert indiv.infection_severity == 0.0\n    assert indiv.interact_range == 2\n    assert indiv.sight_range == 5\n    indiv.add_connection(Individual(2, State.INFECTED, (1, 1)))",
        "detail": "test_population",
        "documentation": {}
    },
    {
        "label": "test_update_state",
        "kind": 2,
        "importPath": "test_population",
        "description": "test_population",
        "peekOfCode": "def test_update_state():\n    random.seed(0)\n    indiv = Individual(1, State.HEALTHY, (1, 1))\n    indiv.add_connection(Individual(2, State.ZOMBIE, (0, 0)))\n    indiv.add_connection(Individual(3, State.ZOMBIE, (0, 1)))\n    indiv.add_connection(Individual(4, State.ZOMBIE, (0, 2)))\n    indiv.add_connection(Individual(5, State.ZOMBIE, (1, 0)))\n    indiv.add_connection(Individual(6, State.ZOMBIE, (1, 2)))\n    indiv.add_connection(Individual(7, State.ZOMBIE, (2, 0)))\n    indiv.add_connection(Individual(8, State.ZOMBIE, (2, 2)))",
        "detail": "test_population",
        "documentation": {}
    },
    {
        "label": "test_is_died",
        "kind": 2,
        "importPath": "test_population",
        "description": "test_population",
        "peekOfCode": "def test_is_died():\n    indiv = Individual(1, State.INFECTED, (0, 0))\n    indiv.connections = [Individual(2, State.ZOMBIE, (1, 1))]\n    assert indiv.is_died(0.5) == False\n    indiv.connections = [Individual(2, State.HEALTHY, (1, 1))]\n    assert indiv.is_died(1) == True\ndef test_is_turned():\n    indiv = Individual(1, State.INFECTED, (0, 0))\n    indiv.infection_severity = 0.1\n    assert indiv.is_turned() == False",
        "detail": "test_population",
        "documentation": {}
    },
    {
        "label": "test_is_turned",
        "kind": 2,
        "importPath": "test_population",
        "description": "test_population",
        "peekOfCode": "def test_is_turned():\n    indiv = Individual(1, State.INFECTED, (0, 0))\n    indiv.infection_severity = 0.1\n    assert indiv.is_turned() == False\n    indiv.infection_severity = 1\n    assert indiv.is_turned() == True\ndef test_is_infected():\n    indiv = Individual(1, State.HEALTHY, (0, 0))\n    indiv.connections = [Individual(2, State.HEALTHY, (1, 1))]\n    assert indiv.is_infected(1.0) == False",
        "detail": "test_population",
        "documentation": {}
    },
    {
        "label": "test_is_infected",
        "kind": 2,
        "importPath": "test_population",
        "description": "test_population",
        "peekOfCode": "def test_is_infected():\n    indiv = Individual(1, State.HEALTHY, (0, 0))\n    indiv.connections = [Individual(2, State.HEALTHY, (1, 1))]\n    assert indiv.is_infected(1.0) == False\n    indiv.connections = [Individual(2, State.ZOMBIE, (1, 1))]\n    assert indiv.is_infected(1.0) == True",
        "detail": "test_population",
        "documentation": {}
    },
    {
        "label": "PerformanceDecorator",
        "kind": 6,
        "importPath": "timeit_decorator",
        "description": "timeit_decorator",
        "peekOfCode": "class PerformanceDecorator:\n    def __init__(self, func):\n        self.func = func\n        update_wrapper(self, func)\n    def time_it(self, *args, **kwargs):\n        # Run the function using timeit.repeat and return the average execution time\n        t = timeit.Timer(lambda: self.func(*args, **kwargs))\n        res = t.repeat(repeat=10, number=100)\n        time = min(res) / 100\n        print(f'Execution time of {self.func.__name__} is {time:.5f} seconds')",
        "detail": "timeit_decorator",
        "documentation": {}
    },
    {
        "label": "performance_decorator",
        "kind": 2,
        "importPath": "timeit_decorator",
        "description": "timeit_decorator",
        "peekOfCode": "def performance_decorator(mode='all'):\n    def _performance_decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            if mode == 'time_it' or mode == 'all':\n                # Run the function using timeit.repeat and return the average execution time\n                t = timeit.Timer(lambda: func(*args, **kwargs))\n                res = t.repeat(repeat=10, number=100)\n                time = min(res) / 100\n                try:",
        "detail": "timeit_decorator",
        "documentation": {}
    },
    {
        "label": "time_count_decorator",
        "kind": 2,
        "importPath": "timeit_decorator",
        "description": "timeit_decorator",
        "peekOfCode": "def time_count_decorator(init_func=None, *, time_unit='sec'):\n    if init_func is None:\n        return partial(time_count_decorator,time_unit=time_unit)\n    @wraps(init_func)\n    def time_count(*pos_args,**kw_args): \n        ''' The docstring of time_count '''  \n        ts = time.time()\n        return_value = init_func(*pos_args,**kw_args) \n        te = time.time()\n        if time_unit == 'sec':",
        "detail": "timeit_decorator",
        "documentation": {}
    },
    {
        "label": "use_counter_to_count",
        "kind": 2,
        "importPath": "timeit_decorator",
        "description": "timeit_decorator",
        "peekOfCode": "def use_counter_to_count(times):\n    A2Z1000 = ''.join(chr(i) for i in range(97, 123)) * times\n    d = Counter()\n    for c in A2Z1000:\n        d[c] += 1\n    return d\n#@performance_decorator(mode='all')\ndef counter_update_count(times):\n    A2Z1000 = ''.join(chr(i) for i in range(97, 123)) * times\n    d = Counter()",
        "detail": "timeit_decorator",
        "documentation": {}
    },
    {
        "label": "counter_update_count",
        "kind": 2,
        "importPath": "timeit_decorator",
        "description": "timeit_decorator",
        "peekOfCode": "def counter_update_count(times):\n    A2Z1000 = ''.join(chr(i) for i in range(97, 123)) * times\n    d = Counter()\n    d.update(A2Z1000)\n    return d\n#@performance_decorator(mode='all')\ndef counter_count(times):\n    A2Z1000 = ''.join(chr(i) for i in range(97, 123)) * times\n    d = Counter(A2Z1000)\n    return d",
        "detail": "timeit_decorator",
        "documentation": {}
    },
    {
        "label": "counter_count",
        "kind": 2,
        "importPath": "timeit_decorator",
        "description": "timeit_decorator",
        "peekOfCode": "def counter_count(times):\n    A2Z1000 = ''.join(chr(i) for i in range(97, 123)) * times\n    d = Counter(A2Z1000)\n    return d\n\"\"\"\n# example 1\ny = use_counter_to_count(1000)\nprint(y)\n#y = counter_update_count(1000)\n#print(y)",
        "detail": "timeit_decorator",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "timeit_decorator",
        "description": "timeit_decorator",
        "peekOfCode": "y = use_counter_to_count(1000)\nprint(y)\n#y = counter_update_count(1000)\n#print(y)\n#y = counter_count(1000)\n#print(y)\n\"\"\"\n\"\"\"\n# example 2\ndecorator = PerformanceDecorator(use_counter_to_count)",
        "detail": "timeit_decorator",
        "documentation": {}
    },
    {
        "label": "#y",
        "kind": 5,
        "importPath": "timeit_decorator",
        "description": "timeit_decorator",
        "peekOfCode": "#y = counter_update_count(1000)\n#print(y)\n#y = counter_count(1000)\n#print(y)\n\"\"\"\n\"\"\"\n# example 2\ndecorator = PerformanceDecorator(use_counter_to_count)\ndecorator.time_it(1000)\ndecorator.call_count(1000)",
        "detail": "timeit_decorator",
        "documentation": {}
    },
    {
        "label": "#y",
        "kind": 5,
        "importPath": "timeit_decorator",
        "description": "timeit_decorator",
        "peekOfCode": "#y = counter_count(1000)\n#print(y)\n\"\"\"\n\"\"\"\n# example 2\ndecorator = PerformanceDecorator(use_counter_to_count)\ndecorator.time_it(1000)\ndecorator.call_count(1000)\ndecorator.line_profile(1000)\ndecorator.memory_profile(1000)",
        "detail": "timeit_decorator",
        "documentation": {}
    },
    {
        "label": "decorator",
        "kind": 5,
        "importPath": "timeit_decorator",
        "description": "timeit_decorator",
        "peekOfCode": "decorator = PerformanceDecorator(use_counter_to_count)\ndecorator.time_it(1000)\ndecorator.call_count(1000)\ndecorator.line_profile(1000)\ndecorator.memory_profile(1000)\nresult = decorator.call(1000)\nprint(result)\n\"\"\"\n\"\"\"\nhttps://myapollo.com.tw/zh-tw/cprofile-and-py-spy-tutorial/",
        "detail": "timeit_decorator",
        "documentation": {}
    },
    {
        "label": "result",
        "kind": 5,
        "importPath": "timeit_decorator",
        "description": "timeit_decorator",
        "peekOfCode": "result = decorator.call(1000)\nprint(result)\n\"\"\"\n\"\"\"\nhttps://myapollo.com.tw/zh-tw/cprofile-and-py-spy-tutorial/\nhttps://myapollo.com.tw/zh-tw/fil-memory-usage-profiler/\nhttps://myapollo.com.tw/zh-tw/python-concurrent-futures/\nhttps://myapollo.com.tw/zh-tw/python-multiprocessing/\nhttps://myapollo.com.tw/zh-tw/more-about-python-multiprocessing/\nhttps://myapollo.com.tw/zh-tw/begin-to-asyncio/",
        "detail": "timeit_decorator",
        "documentation": {}
    },
    {
        "label": "Object",
        "kind": 6,
        "importPath": "zombie",
        "description": "zombie",
        "peekOfCode": "class Object:\n    def __init__(self, row: int, column: int, name: Optional[str] = None):\n        # set row and column\n        self.row, self.column = row, column\n        # set name\n        self.name = name\n# food class\nclass Food(Object):\n    counter = 0\n    # init food",
        "detail": "zombie",
        "documentation": {}
    },
    {
        "label": "Food",
        "kind": 6,
        "importPath": "zombie",
        "description": "zombie",
        "peekOfCode": "class Food(Object):\n    counter = 0\n    # init food\n    FOOD = range(10, 20)\n    def __init__(self, row: int, column: int, name: Optional[str] = None, amount: int = -1, *args):\n        super().__init__(row, column, name)\n        # count food\n        Food.counter += 1\n        self.id = Food.counter\n        # set food",
        "detail": "zombie",
        "documentation": {}
    },
    {
        "label": "Weapon",
        "kind": 6,
        "importPath": "zombie",
        "description": "zombie",
        "peekOfCode": "class Weapon(Object):\n    counter = 0\n    # init attribute\n    ATTRIBUTE = {\"health\": range(10, 20), \"damage\": range(\n        5, 10), \"aoe\": range(1, 2)}\n    def __init__(self, row: int, column: int, name: Optional[str] = None, attribute: Optional[str] = None, amount: int = -1, *args):\n        super().__init__(row, column, name)\n        # count weapons\n        Weapon.counter += 1\n        self.id = Weapon.counter",
        "detail": "zombie",
        "documentation": {}
    },
    {
        "label": "Character",
        "kind": 6,
        "importPath": "zombie",
        "description": "zombie",
        "peekOfCode": "class Character(Object):\n    # init health, damage, aoe\n    HEALTH = range(0, 1)\n    DAMAGE = range(0, 1)\n    AOE = range(0, 1)\n    def __init__(self, row: int, column: int, name: Optional[str] = None, health: int = -1, damage: int = -1, aoe: int = -1, food: int = 100, *args, **kwargs):\n        super().__init__(row, column, name)\n        # set health, damage, aoe, food\n        if health == -1:\n            health = random.choice(self.HEALTH)",
        "detail": "zombie",
        "documentation": {}
    },
    {
        "label": "Human",
        "kind": 6,
        "importPath": "zombie",
        "description": "zombie",
        "peekOfCode": "class Human(Character):\n    counter = 0\n    # init human health, damage, aoe\n    HEALTH = range(10, 50)\n    DAMAGE = range(1, 3)\n    AOE = range(1, 2)\n    # make use of character id and counter (faster calculation or import models)\n    # separate count method\n    def __init__(self, row: int, column: int, name: Optional[str] = None, health: int = -1, damage: int = -1, aoe: int = -1, food: int = 100, weapon: Optional[Weapon] = None, *args, **kwargs):\n        # get human health, damage, aoe",
        "detail": "zombie",
        "documentation": {}
    },
    {
        "label": "Zombie",
        "kind": 6,
        "importPath": "zombie",
        "description": "zombie",
        "peekOfCode": "class Zombie(Character):\n    counter = 0\n    # init zombie health, damage, aoe\n    HEALTH = range(10, 50)\n    DAMAGE = range(1, 3)\n    AOE = range(1, 2)\n    def __init__(self, row: int, column: int, name: Optional[str] = None, health: int = -1, damage: int = -1, aoe: int = -1, food: int = 100, *args, **kwargs):\n        # get human health, damage, aoe\n        super().__init__(row, column, name, health, damage, aoe, food)\n        # count zombies",
        "detail": "zombie",
        "documentation": {}
    },
    {
        "label": "Grid",
        "kind": 6,
        "importPath": "zombie",
        "description": "zombie",
        "peekOfCode": "class Grid:\n    def __init__(self, m: int, n: int, food_prob: float, weapon_prob: float):\n        # set grid size\n        self.m, self.n = m, n\n        # set grid\n        self.grid: list[list[Optional[Object]]] = [\n            [None] * n for _ in range(m)]\n        # set food and weapon probability\n        self.food_prob = food_prob\n        self.weapon_prob = weapon_prob",
        "detail": "zombie",
        "documentation": {}
    },
    {
        "label": "time_it",
        "kind": 2,
        "importPath": "zombie",
        "description": "zombie",
        "peekOfCode": "def time_it(func):\n    import time\n    def wrapper(*args, **kwargs):\n        start = time.time()\n        result = func(*args, **kwargs)\n        end = time.time()\n        print(f\"Total time taken in : {func.__name__} is {end - start}\")\n        return result\n    return wrapper\n# use functools for debugging",
        "detail": "zombie",
        "documentation": {}
    },
    {
        "label": "debug",
        "kind": 2,
        "importPath": "zombie",
        "description": "zombie",
        "peekOfCode": "def debug(func):\n    import functools\n    @functools.wraps(func)\n    def wrapper_debug(*args, **kwargs):\n        args_repr = [repr(a) for a in args]                      # 1\n        kwargs_repr = [f\"{k}={v!r}\" for k, v in kwargs.items()]  # 2\n        signature = \", \".join(args_repr + kwargs_repr)           # 3\n        print(f\"Calling {func.__name__}({signature})\")\n        value = func(*args, **kwargs)\n        print(f\"{func.__name__!r} returned {value!r}\")           # 4",
        "detail": "zombie",
        "documentation": {}
    },
    {
        "label": "test_characters",
        "kind": 2,
        "importPath": "zombie",
        "description": "zombie",
        "peekOfCode": "def test_characters():\n    Human.counter = 0\n    human1 = Human(0, 0)\n    print(human1)\n    print(human1.info())\n    human1.attack(2)\n    print(human1.info())\n    human1.heal(3)\n    print(human1.info())\n    food1 = Food(0, 1)",
        "detail": "zombie",
        "documentation": {}
    },
    {
        "label": "euclidean_distance",
        "kind": 2,
        "importPath": "zombie",
        "description": "zombie",
        "peekOfCode": "def euclidean_distance(vx, vy):\n    return sum((y-x)**2 for x, y in zip(vx, vy)) ** 0.5\n# grid class\nclass Grid:\n    def __init__(self, m: int, n: int, food_prob: float, weapon_prob: float):\n        # set grid size\n        self.m, self.n = m, n\n        # set grid\n        self.grid: list[list[Optional[Object]]] = [\n            [None] * n for _ in range(m)]",
        "detail": "zombie",
        "documentation": {}
    },
    {
        "label": "test_environment",
        "kind": 2,
        "importPath": "zombie",
        "description": "zombie",
        "peekOfCode": "def test_environment():\n    grid = Grid(m=4, n=4, food_prob=0.001, weapon_prob=0.1)\n    print(grid.size())\n    Human.counter = 0\n    Zombie.counter = 0\n    Food.counter = 0\n    Weapon.counter = 0\n    while (Human.counter < 2):\n        row = random.choice(range(0, grid.m))\n        col = random.choice(range(0, grid.n))",
        "detail": "zombie",
        "documentation": {}
    }
]